<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- qobjectxmlmodel.qdoc -->
<head>
  <title>Qt 4.6: QObject XML Model Example</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot; <a href="overviews.html"><font color="#004faf">Overviews</font></a></td></tr></table><h1 class="title">QObject XML Model Example<br /><span class="subtitle"></span>
</h1>
<p>Files:</p>
<ul>
<li><a href="xmlpatterns-qobjectxmlmodel-mainwindow-cpp.html">xmlpatterns/qobjectxmlmodel/mainwindow.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-mainwindow-h.html">xmlpatterns/qobjectxmlmodel/mainwindow.h</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-cpp.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-h.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.h</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-forms-mainwindow-ui.html">xmlpatterns/qobjectxmlmodel/forms/mainwindow.ui</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-statisticsinhtml-xq.html">xmlpatterns/qobjectxmlmodel/queries/statisticsInHTML.xq</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-wholetree-xq.html">xmlpatterns/qobjectxmlmodel/queries/wholeTree.xq</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-main-cpp.html">xmlpatterns/qobjectxmlmodel/main.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-pro.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.pro</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-qrc.html">xmlpatterns/qobjectxmlmodel/queries.qrc</a></li>
</ul>
<p>This example shows how to use <a href="qtxmlpatterns.html">QtXmlPatterns</a> to query <a href="qobject.html">QObject</a> trees by modeling the non-XML data structure of a <a href="qobject.html">QObject</a> tree to look like XML.</p>
<ul><li><a href="#introduction">Introduction</a></li>
<ul><li><a href="#the-user-interface">The User Interface</a></li>
</ul>
<li><a href="#code-walk-through">Code Walk-Through</a></li>
<ul><li><a href="#the-custom-node-model-class-qobjextxmlmodel">The Custom Node Model Class: QObjextXmlModel</a></li>
<ul><li><a href="#accessing-the-node-model">Accessing The Node Model</a></li>
<li><a href="#traversing-the-node-model">Traversing The Node Model</a></li>
<li><a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a></li>
</ul>
</ul>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>This example illustrates two important points about using XQuery to query non-XML data modeled to look like XML. The first point is that a custom node model class doesn't always have to actually build the node model. Sometimes the node model can be an already existing data structure, like the <a href="qobject.html">QObject</a> tree used in this example. The second point is to explain what is required to make non-XML data look like XML.</p>
<p>In this example, we want to model a <a href="qobject.html">QObject</a> tree to look like XML. That is easy to do because a <a href="qobject.html">QObject</a> tree maps to the XML tree structure in a staightforward way. Each <a href="qobject.html">QObject</a> node is modeled as an XML element node. However, when we want to add the <a href="qmetaobject.html">QMetaObject</a> tree to the <a href="qobject.html">QObject</a> tree node model, we are trying to add a second tree to the node model. The <a href="qmetaobject.html">QMetaObject</a> tree exists <i>behind</i> the <a href="qobject.html">QObject</a> tree. Adding the <a href="qmetaobject.html">QMetaObject</a> tree to the node model changes the two dimensional tree into a three dimensional tree.</p>
<p>The query engine can only traverse two dimensional trees, because an XML document is always a two dimensional tree. If we want to add the <a href="qmetaobject.html">QMetaObject</a> tree to the node model, we have to somehow flatten it into the same plane as the <a href="qobject.html">QObject</a> tree. This requires that the node model class must build an auxiliary data structure and make it part of the two dimensional <a href="qobject.html">QObject</a> node model. How to do this is explained in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="the-user-interface"></a>
<h3>The User Interface</h3>
<p>The UI for this example was created using Qt Designer:</p>
<p align="center"><img src="images/qobjectxmlmodel-example.png" /></p><a name="code-walk-through"></a>
<h2>Code Walk-Through</h2>
<p>The strategy for this example is different from the strategy for the <a href="xmlpatterns-filetree.html">file system example</a>. In the file system example, the node model class had to actually build a node model because the non-XML data to be traversed was the computer's file system, a structure stored on disk in a form that the query engine couldn't use. The node model class had to build an analog of the computer's file system in memory.</p>
<p>For this example, the data structure to be traversed already exists in memory in a usable form. It is the <a href="qobject.html">QObject</a> tree of the example application itself. All we need is the pointer to the root of the <a href="qobject.html">QObject</a> tree.</p>
<p><b>Note:</b> When we add the <a href="qmetaobject.html">QMetaObject</a> tree to the node model, the node model class will have to build an auxiliary data structure to move the <a href="qmetaobject.html">QMetaObject</a> tree into the same plane as the <a href="qobject.html">QObject</a> tree. This is explained later in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="the-custom-node-model-class-qobjextxmlmodel"></a>
<h3>The Custom Node Model Class: QObjextXmlModel</h3>
<p>The node model class for this example is QObjextXmlModel, which is derived from <a href="qsimplexmlnodemodel.html">QSimpleXmlNodeModel</a>. QObjextXmlModel implements the callback interface functions that don't have implementations in <a href="qsimplexmlnodemodel.html">QSimpleXmlNodeModel</a>:</p>
<pre>     virtual QXmlNodeModelIndex::DocumentOrder compareOrder(const QXmlNodeModelIndex &amp;n1, const QXmlNodeModelIndex &amp;n2) const;
     virtual QXmlName name(const QXmlNodeModelIndex &amp;n) const;
     virtual QUrl documentUri(const QXmlNodeModelIndex &amp;n) const;
     virtual QXmlNodeModelIndex::NodeKind kind(const QXmlNodeModelIndex &amp;n) const;
     virtual QXmlNodeModelIndex root(const QXmlNodeModelIndex &amp;n) const;
     virtual QVariant typedValue(const QXmlNodeModelIndex &amp;n) const;
     virtual QVector&lt;QXmlNodeModelIndex&gt; attributes(const QXmlNodeModelIndex&amp;) const;
     virtual QXmlNodeModelIndex nextFromSimpleAxis(SimpleAxis, const QXmlNodeModelIndex&amp;) const;</pre>
<p>The node model class declares three data members:</p>
<a name="three-data-members"></a><pre>     const QUrl              m_baseURI;
     QObject *const          m_root;
     const AllMetaObjects    m_allMetaObjects;</pre>
<p>The constructor sets <tt>m_baseURI</tt> to the <a href="qurl.html">QUrl</a> constructed from the <a href="qcoreapplication.html#applicationFilePath">file path</a> of the application executable. This is the value returned by <a href="qabstractxmlnodemodel.html#documentUri">documentUri()</a>. The constructor sets <tt>m_root</tt> to point to the <a href="qobject.html">QObject</a> tree for the example application. This is the node model that the query engine will use. And the constructor calls a local function to build the auxiliary data structure (<tt>m_allMetaObjects</tt>) for including the <a href="qmetaobject.html">QMetaObject</a> tree in the node model. How this auxiliary data structure is incorporated into the <a href="qobject.html">QObject</a> node model is discussed in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="accessing-the-node-model"></a>
<h4>Accessing The Node Model</h4>
<p>Since the query engine knows nothing about <a href="qobject.html">QObject</a> trees, it can only access them by calling functions in the node model callback interface. The query engine passes a <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> to uniquely identify a node in the node model. The <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> is constructed from a pointer to the <a href="qobject.html">QObject</a> that represents the node. <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> creates the <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a>, as in the local <tt>root()</tt> function, for example:</p>
<pre> QXmlNodeModelIndex QObjectXmlModel::root() const
 {
     return createIndex(m_root);
 }</pre>
<p>A <a href="qobject.html">QObject</a> represents an element node in the node model, but we also need to represent attribute nodes. For example, the class name of a <a href="qobject.html">QObject</a> is an attribute of the <a href="qobject.html">QObject</a>, so it should be an attribute node in the node model. A <a href="qobject.html">QObject</a>'s class name is obtained from the <a href="qobject.html">QObject</a>. (Actually, it is in the <a href="qmetaobject.html">QMetaObject</a>, which is obtained from the <a href="qobject.html">QObject</a>). This means that a single <a href="qobject.html">QObject</a> logically represents multiple nodes in the node model: the element node and potentially many attribute nodes.</p>
<p>To uniquely identify an attribute node, we need the pointer to the <a href="qobject.html">QObject</a> containing the attribute, and an additional value that identifies the attribute in the <a href="qobject.html">QObject</a>. For this <i>additional data</i> value, we use <tt>enum QObjectNodeType</tt>:</p>
<pre>     enum QObjectNodeType
     {
         IsQObject               = 0,
         QObjectProperty         = 1 &lt;&lt; 26,
         MetaObjects             = 2 &lt;&lt; 26,
         MetaObject              = 3 &lt;&lt; 26,
         MetaObjectClassName     = 4 &lt;&lt; 26,
         MetaObjectSuperClass    = 5 &lt;&lt; 26,
         QObjectClassName        = 6 &lt;&lt; 26
     };</pre>
<p>Ignore the <tt>MetaObjectXXX</tt> values for now. They will be explained in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>. Here we are interested in the three node types for <a href="qobject.html">QObject</a> nodes: <tt>IsQObject</tt>, which represents the element node type for a <a href="qobject.html">QObject</a>, and <tt>QObjectProperty</tt> and <tt>QObjectClassName</tt>, which represent the attribute node types for the attributes of a <a href="qobject.html">QObject</a>.</p>
<p>The <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> function called in the <tt>root()</tt> snippet above is the overload that accepts a <tt>void*</tt> pointer and a second parameter, <tt>additionalData</tt>, with default value 0 (<tt>IsQObject</tt>). Wherever you see a call to <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> that only passes the <a href="qobject.html">QObject</a> pointer, it is creating the node index for a <a href="qobject.html">QObject</a> element node. To create the node index for the class name attribute, for example, the <a href="#qobject-attributes">attributes()</a> function uses <tt>createIndex(object,QObjectClassName)</tt>.</p>
<a name="qobject-attributes"></a><pre> QVector&lt;QXmlNodeModelIndex&gt; QObjectXmlModel::attributes(const QXmlNodeModelIndex&amp; n) const
 {
      QVector&lt;QXmlNodeModelIndex&gt; result;
      QObject *const object = asQObject(n);

      switch(toNodeType(n))
      {
         case IsQObject:
         {
             const QMetaObject *const metaObject = object-&gt;metaObject();
             const int count = metaObject-&gt;propertyCount();
             result.append(createIndex(object, QObjectClassName));

             for (int i = 0; i &lt; count; ++i) {
                 const QMetaProperty qmp(metaObject-&gt;property(i));
                 const int ii = metaObject-&gt;indexOfProperty(qmp.name());
                 if (i == ii)
                     result.append(createIndex(object, QObjectProperty | i));
             }
             return result;
         }
         default:
             return QVector&lt;QXmlNodeModelIndex&gt;();
      }
 }</pre>
<p><a href="#qobject-attributes">attributes()</a> is one of the callback functions you have to implement in your custom node model class. It returns a <a href="qvector.html">QVector</a> of <a href="qxmlnodemodelindex.html">node indexes</a> for all the attribute nodes for <a href="qobject.html">QObject</a> <tt>n</tt>. It calls <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> in two places. Both calls use the <a href="qobject.html">QObject</a> pointer from the current node <tt>n</tt> (the element node), and just add a different value for the <i>additional data</i> parameter. This makes sense because, in XML, the attributes of an element are part of that element.</p>
<a name="traversing-the-node-model"></a>
<h4>Traversing The Node Model</h4>
<p>The query engine traverses the <a href="qobject.html">QObject</a> tree by calling back to the node model class's implementation of <a href="#qobject-nextfromsimpleaxis">nextFromSimpleAxis()</a>. This function is the heart of the callback interface, and it will probably be the most complex to implement in your custom node model class. Below is a partial listing of the implementation for this example. The full listing will be shown in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>, where we discuss traversing the <a href="qmetaobject.html">QMetaObject</a> tree.</p>
<a name="qobject-nextfromsimpleaxis"></a><pre> QXmlNodeModelIndex QObjectXmlModel::nextFromSimpleAxis(SimpleAxis axis, const QXmlNodeModelIndex &amp;n) const
 {
     switch (toNodeType(n))
     {
         case IsQObject:
         {
             switch (axis)
             {
                 case Parent:
                     return createIndex(asQObject(n)-&gt;parent());

                 case FirstChild:
                 {
                     if (!asQObject(n) || asQObject(n)-&gt;children().isEmpty())
                         return QXmlNodeModelIndex();
                     else
                         return createIndex(asQObject(n)-&gt;children().first());
                 }

                 case NextSibling:
                     return qObjectSibling(1, n);

                 case PreviousSibling:
                 {
                     if (asQObject(n) == m_root)
                         return createIndex(qint64(0), MetaObjects);
                     else
                         return qObjectSibling(-1, n);
                 }
             }
             Q_ASSERT(false);
         }

         case QObjectClassName:
         case QObjectProperty:
         {
             Q_ASSERT(axis == Parent);
             return createIndex(asQObject(n));
         }
     }

     Q_ASSERT(false);
     return QXmlNodeModelIndex();
 }</pre>
<p>The main switch uses <tt>toNodeType()</tt>, which obtains the node type from <a href="qxmlnodemodelindex.html#additionalData">QXmlNodeModelIndex::additionalData</a>():</p>
<pre> QObjectXmlModel::QObjectNodeType QObjectXmlModel::toNodeType(const QXmlNodeModelIndex &amp;n)
 {
     return QObjectNodeType(n.additionalData() &amp; (15 &lt;&lt; 26));
 }</pre>
<p><tt>case IsObject</tt> case is the most interesting. It switches again on the value of the <tt>axis</tt> parameter, which specifies the direction the query engine wants to take from the current node. It is one of the four enum values of <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">QAbstractXmlNodeModel::SimpleAxis</a>. The <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a> and <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">FirstChild</a> cases reduce to calls to <a href="qobject.html#parent">QObject::parent</a>() and <a href="qobject.html#children">QObject::children</a>() respectively. Note that a default constructed <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> is returned in the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a> case if the current node is the root, and in the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">FirstChild</a> case if the current node has no children.</p>
<p>For the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">NextSibling</a> and <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a> axes, the helper function <tt>qObjectSibling()</tt> is called, with +1 to traverse to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">NextSibling</a> and -1 to traverse to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a>.</p>
<pre> QXmlNodeModelIndex QObjectXmlModel::qObjectSibling(const int pos, const QXmlNodeModelIndex &amp;n) const
 {
     Q_ASSERT(pos == 1 || pos == -1);
     Q_ASSERT(asQObject(n));

     const QObject *parent = asQObject(n)-&gt;parent();
     if (parent) {
         const QList&lt;QObject *&gt; &amp;children = parent-&gt;children();
         const int siblingPos = children.indexOf(asQObject(n)) + pos;

         if (siblingPos &gt;= 0 &amp;&amp; siblingPos &lt; children.count())
             return createIndex(children.at(siblingPos));
         else
             return QXmlNodeModelIndex();
     }
     else
         return QXmlNodeModelIndex();
 }</pre>
<p><tt>qObjectSibling()</tt> determines whether or not the node has any siblings. It is called with <tt>n</tt>, the index of the current node. If the current node is a child, then it has a parent with children (the current node one of these). So, we get the <a href="qobject.html#parent">parent</a>, obtain the parent's <a href="qobject.html#children">child list</a>, find the current node in the list, and construct the node index for the next or previous child (sibling) and return it.</p>
<p><b>Note:</b> In <a href="#qobject-nextfromsimpleaxis">nextFromSimpleAxis()</a>, the special case of asking for the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a> of the root node is discussed in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<p>Traversing away from a <tt>QObjectClassName</tt> attribute node or a <tt>QObjectProperty</tt> attribute node might seem a bit confusing at first glance. The only move allowed from an attribute node is to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a>, because attribute nodes don't have children. But these two cases simply return the <a href="qxmlnodemodelindex.html">node index</a> of the current node.</p>
<pre>         case QObjectClassName:
         case QObjectProperty:
         {
             Q_ASSERT(axis == Parent);
             return createIndex(asQObject(n));
         }</pre>
<p>Since <tt>n</tt> is the <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> of the current node, all this does is create another <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> for the current node and return it. This was explained above in <a href="#accessing-the-node-model">Accessing The Node Model</a>, where we saw that each <a href="qobject.html">QObject</a> in the node model actually represents an element node and potentially many attribute nodes. Traversing to the parent node of an attribute simply creates a node index for the same <a href="qobject.html">QObject</a>, but with an <i>additional data</i> value of 0 (<tt>IsQObject</tt>).</p>
<p>If we only wanted to traverse the <a href="qobject.html">QObject</a> tree with XQuery, we could just implement the rest of the virtual callback functions listed earlier and we would be done. The implementations for the remaining functions are straightforward. But if we also want to use XQuery to traverse the <a href="qmetaobject.html">QMetaObject</a> tree, we must include the <a href="qmetaobject.html">QMetaObject</a> tree in the custom node model.</p>
<a name="including-the-qmetaobject-tree"></a>
<h4>Including The QMetaObject Tree</h4>
<p>The <a href="metaobjects.html">metaobject system</a> not only enables Qt's <a href="signalsandslots.html">signals and slots</a>, it also provides type information that is useful at run-time; e.g&#x2e;, getting and setting properties without knowing the property names at compile time. Each <a href="qobject.html">QObject</a> has an associated <a href="qmetaobject.html">QMetaObject</a> tree which contains all this useful type information. Given a <a href="qobject.html">QObject</a>, its <a href="qmetaobject.html">QMetaObject</a> is obtained with <a href="qobject.html#metaObject">QObject::metaObject</a>(). Then <a href="qmetaobject.html#superClass">QMetaObject::superClass</a>() can be called repeatedly to get the <a href="qmetaobject.html">QMetaObject</a> for each class in the class hierarchy for the original <a href="qobject.html">QObject</a>.</p>
<p>However, the <a href="qmetaobject.html">QMetaObject</a> hierarchy is a second tree in a plan that exists logically behind the plane of the <a href="qobject.html">QObject</a> tree. The <a href="qtxmlpatterns.html">QtXmlPatterns</a> query engine can only traverse a two dimensional node model that represents an XML tree. If we want to include the <a href="qmetaobject.html">QMetaObject</a> in the same node model that represents the <a href="qobject.html">QObject</a> tree, we must find a way to flatten the <a href="qmetaobject.html">QMetaObject</a> tree into the same plane as the <a href="qobject.html">QObject</a> tree.</p>
<p>The node model class declares <a href="#all-metaobjects">m_allMetaObjects</a> as a vector of pointers to <a href="qmetaobject.html">QMetaObject</a>:</p>
<a name="all-metaobjects"></a><pre>     typedef QVector&lt;const QMetaObject *&gt; AllMetaObjects;
     const AllMetaObjects    m_allMetaObjects;</pre>
<p>This vector gets populated by the QObjectXmlModel constructor by calling the private allMetaObjects() function:</p>
<pre> QObjectXmlModel::AllMetaObjects QObjectXmlModel::allMetaObjects() const
 {
     QXmlQuery query(namePool());
     query.bindVariable(&quot;root&quot;, root());
     query.setQuery(&quot;declare variable $root external;&quot;
                    &quot;$root/descendant-or-self::QObject&quot;);
     Q_ASSERT(query.isValid());

     QXmlResultItems result;
     query.evaluateTo(&amp;result);
     QXmlItem i(result.next());

     AllMetaObjects objects;
     while (!i.isNull()) {
         const QMetaObject *moo = asQObject(i.toNodeModelIndex())-&gt;metaObject();
         while (moo) {
             if (!objects.contains(moo))
                 objects.append(moo);
             moo = moo-&gt;superClass();
         }
         i = result.next();
     }

     Q_ASSERT(!objects.contains(0));
     return objects;
 }</pre>
<p>The first half of the function is an example of the standard code pattern for using <a href="qtxmlpatterns.html">QtXmlPatterns</a> to run an XQuery. First it creates an instance of <a href="qxmlquery.html">QXmlQuery</a>. Then it <a href="qxmlquery.html#bindVariable">binds</a> the XQuery variable <tt>$root</tt> to the root node of the of the node model; i.e&#x2e;, the root of the <a href="qobject.html">QObject</a> tree. Then it <a href="qxmlquery.html#setQuery">sets the query</a> to be an XQuery that returns all the QObjects in the node model. Finally, the query is evaluated into a <a href="qxmlresultitems.html">result item list</a>.</p>
<p><b>Note:</b> <a href="qxmlquery.html#bindVariable">QXmlQuery::bindVariable</a>() must be called before <a href="qxmlquery.html#setQuery">QXmlQuery::setQuery</a>(), because setting the query causes <a href="qtxmlpatterns.html">QtXmlPatterns</a> to <i>compile</i> the XQuery, which requires knowledge of the variable bindings.</p>
<p>The second half of the function traverses the <a href="qxmlresultitems.html">result item list</a>, getting the <a href="qmetaobject.html">QMetaObject</a> hierarchy for each <a href="qobject.html">QObject</a> and appending it to <a href="#all-metaobjects">m_allMetaObjects</a>, if it isn't already there. But how do we include this vector of pointers to QMetaObjects in the node model? The key insight is shown in the full listing of <a href="#full-listing-of-nextfromsimpleaxis">nextFromSimpleAxis()</a>, where we are interested now in the <tt>MetaObjectXXX</tt> cases:</p>
<a name="full-listing-of-nextfromsimpleaxis"></a><pre> QXmlNodeModelIndex QObjectXmlModel::nextFromSimpleAxis(SimpleAxis axis, const QXmlNodeModelIndex &amp;n) const
 {
     switch (toNodeType(n))
     {
         case IsQObject:
         {
             switch (axis)
             {
                 case Parent:
                     return createIndex(asQObject(n)-&gt;parent());

                 case FirstChild:
                 {
                     if (!asQObject(n) || asQObject(n)-&gt;children().isEmpty())
                         return QXmlNodeModelIndex();
                     else
                         return createIndex(asQObject(n)-&gt;children().first());
                 }

                 case NextSibling:
                     return qObjectSibling(1, n);

                 case PreviousSibling:
                 {
                     if (asQObject(n) == m_root)
                         return createIndex(qint64(0), MetaObjects);
                     else
                         return qObjectSibling(-1, n);
                 }
             }
             Q_ASSERT(false);
         }

         case QObjectClassName:
         case QObjectProperty:
         {
             Q_ASSERT(axis == Parent);
             return createIndex(asQObject(n));
         }
         case MetaObjects:
         {
             switch (axis)
             {
                 case Parent:
                     return QXmlNodeModelIndex();
                 case PreviousSibling:
                     return QXmlNodeModelIndex();
                 case NextSibling:
                     return root();
                 case FirstChild:
                 {
                     return createIndex(const_cast&lt;QMetaObject*&gt;(m_allMetaObjects.first()),MetaObject);
                 }
             }
             Q_ASSERT(false);
         }

         case MetaObject:
         {
             switch (axis)
             {
                 case FirstChild:
                     return QXmlNodeModelIndex();
                 case Parent:
                     return createIndex(qint64(0), MetaObjects);
                 case PreviousSibling:
                     return metaObjectSibling(-1, n);
                 case NextSibling:
                     return metaObjectSibling(1, n);
             }
         }

         case MetaObjectClassName:
         case MetaObjectSuperClass:
         {
             Q_ASSERT(axis == Parent);
             return createIndex(asQObject(n), MetaObject);
         }
     }

     Q_ASSERT(false);
     return QXmlNodeModelIndex();
 }</pre>
<p>But first, revisit the <tt>PreviousSibling</tt> case for the <tt>IsQObject</tt> case:</p>
<pre>                 case PreviousSibling:
                 {
                     if (asQObject(n) == m_root)
                         return createIndex(qint64(0), MetaObjects);
                     else
                         return qObjectSibling(-1, n);
                 }</pre>
<p>When asking for the previous sibling of the root of the <a href="qobject.html">QObject</a> tree, it creates a node model index with a null <a href="qobject.html">QObject</a> pointer and an <tt>additionalData</tt> value of <tt>MetaObjects</tt>. This effectively allows the query engine to jump from the <a href="qobject.html">QObject</a> tree to the <a href="qmetaobject.html">QMetaObject</a> tree.</p>
<p>The query engine can jump from the <a href="qmetaobject.html">QMetaObject</a> tree back to the <a href="qobject.html">QObject</a> tree in the <tt>NextSibling</tt> case of case <tt>MetaObjects</tt>, where the <tt>root()</tt> function is called:</p>
<pre>         case MetaObjects:
         {
             switch (axis)
             {
                 case Parent:
                     return QXmlNodeModelIndex();
                 case PreviousSibling:
                     return QXmlNodeModelIndex();
                 case NextSibling:
                     return root();
                 case FirstChild:
                 {
                     return createIndex(const_cast&lt;QMetaObject*&gt;(m_allMetaObjects.first()),MetaObject);
                 }
             }
             Q_ASSERT(false);
         }</pre>
<p>Having jumped from the <a href="qobject.html">QObject</a> tree to the <a href="qmetaobject.html">QMetaObject</a> tree, the query engine will use the <tt>MetaObject</tt>, <tt>MetaObjectClassName</tt>, and <tt>MetaObjectSuperClass</tt> cases, which are similar to the cases for <tt>IsQObject</tt>, <tt>QObjectProperty</tt>, and <tt>QObjectClassName</tt>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="40%" align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="40%" align="right"><div align="right">Qt 4.6.0</div></td>
</tr></table></div></address></body>
</html>
