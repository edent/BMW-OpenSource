<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- qstring.cpp -->
<head>
  <title>Qt 4.6: QString Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a name="//apple_ref/cpp/cl//QString" />
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot; <a href="overviews.html"><font color="#004faf">Overviews</font></a></td></tr></table><h1 class="title">QString Class Reference<br /><span class="small-subtitle">[<a href="qtcore.html">QtCore</a> module]</span>
</h1>
<p>The QString class provides a Unicode character string. <a href="#details">More...</a></p>
<pre> #include &lt;QString&gt;</pre><p>Inherited by <a href="qconststring.html" class="compat">QConstString</a>, <a href="qdbusobjectpath.html">QDBusObjectPath</a>, and <a href="qdbussignature.html">QDBusSignature</a>.</p>
<p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html#reentrant">reentrant</a>, except for <a href="qstring-qt3.html#ascii" class="compat">ascii</a>(), <a href="qstring-qt3.html#latin1" class="compat">latin1</a>(), <a href="qstring-qt3.html#utf8" class="compat">utf8</a>(), and <a href="qstring-qt3.html#local8Bit" class="compat">local8Bit</a>(), which are nonreentrant.</p>
<ul>
<li><a href="qstring-members.html">List of all members, including inherited members</a></li>
<li><a href="qstring-qt3.html">Qt 3 support members</a></li>
</ul>
<hr />
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">class </td><td class="memItemRight" valign="bottom"><b><a href="qstring-null.html">Null</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#NormalizationForm-enum">NormalizationForm</a></b> { NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#SectionFlag-enum">SectionFlag</a></b> { SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">flags </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#SectionFlag-enum">SectionFlags</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#SplitBehavior-enum">SplitBehavior</a></b> { KeepEmptyParts, SkipEmptyParts }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#iterator-typedefx">iterator</a></b></td></tr>
</table>
<hr />
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString">QString</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-2">QString</a></b> ( const QChar * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-3">QString</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-4">QString</a></b> ( int <i>size</i>, QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-5">QString</a></b> ( const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-6">QString</a></b> ( const QString &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-7">QString</a></b> ( const char * <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QString-8">QString</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#dtor.QString">~QString</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append">append</a></b> ( const QString &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append-2">append</a></b> ( const QStringRef &amp; <i>reference</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append-3">append</a></b> ( const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append-4">append</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append-5">append</a></b> ( const char * <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#append-6">append</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg">arg</a></b> ( const QString &amp; <i>a</i>, int <i>fieldWidth</i> = 0, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-2">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-3">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-4">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-5">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-6">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-7">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-8">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i>, const QString &amp; <i>a8</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-9">arg</a></b> ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i>, const QString &amp; <i>a8</i>, const QString &amp; <i>a9</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-10">arg</a></b> ( int <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-11">arg</a></b> ( uint <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-12">arg</a></b> ( long <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-13">arg</a></b> ( ulong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-14">arg</a></b> ( qlonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-15">arg</a></b> ( qulonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-16">arg</a></b> ( short <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-17">arg</a></b> ( ushort <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-18">arg</a></b> ( QChar <i>a</i>, int <i>fieldWidth</i> = 0, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-19">arg</a></b> ( char <i>a</i>, int <i>fieldWidth</i> = 0, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#arg-20">arg</a></b> ( double <i>a</i>, int <i>fieldWidth</i> = 0, char <i>format</i> = 'g', int <i>precision</i> = -1, const QChar &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#at">at</a></b> ( int <i>position</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#begin">begin</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#begin-2">begin</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#capacity">capacity</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#chop">chop</a></b> ( int <i>n</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-5">compare</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-6">compare</a></b> ( const QString &amp; <i>other</i>, Qt::CaseSensitivity <i>cs</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-7">compare</a></b> ( const QLatin1String &amp; <i>other</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-8">compare</a></b> ( const QStringRef &amp; <i>ref</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#constBegin">constBegin</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar * </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#constData">constData</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#constEnd">constEnd</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#contains">contains</a></b> ( const QString &amp; <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#contains-4">contains</a></b> ( QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#contains-5">contains</a></b> ( const QRegExp &amp; <i>rx</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#contains-6">contains</a></b> ( QRegExp &amp; <i>rx</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#count">count</a></b> ( const QString &amp; <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#count-2">count</a></b> ( QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#count-3">count</a></b> ( const QRegExp &amp; <i>rx</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#count-4">count</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QChar * </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#data">data</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar * </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#data-2">data</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#end">end</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#end-2">end</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#endsWith">endsWith</a></b> ( const QString &amp; <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#endsWith-3">endsWith</a></b> ( const QLatin1String &amp; <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#endsWith-4">endsWith</a></b> ( const QChar &amp; <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fill">fill</a></b> ( QChar <i>ch</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#indexOf">indexOf</a></b> ( const QString &amp; <i>str</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#indexOf-2">indexOf</a></b> ( const QLatin1String &amp; <i>str</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#indexOf-3">indexOf</a></b> ( QChar <i>ch</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#indexOf-4">indexOf</a></b> ( const QRegExp &amp; <i>rx</i>, int <i>from</i> = 0 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#indexOf-5">indexOf</a></b> ( QRegExp &amp; <i>rx</i>, int <i>from</i> = 0 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#insert">insert</a></b> ( int <i>position</i>, const QString &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#insert-2">insert</a></b> ( int <i>position</i>, const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#insert-3">insert</a></b> ( int <i>position</i>, const QChar * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#insert-4">insert</a></b> ( int <i>position</i>, QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#isEmpty">isEmpty</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#isNull">isNull</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#lastIndexOf">lastIndexOf</a></b> ( const QString &amp; <i>str</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#lastIndexOf-2">lastIndexOf</a></b> ( const QLatin1String &amp; <i>str</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#lastIndexOf-3">lastIndexOf</a></b> ( QChar <i>ch</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#lastIndexOf-4">lastIndexOf</a></b> ( const QRegExp &amp; <i>rx</i>, int <i>from</i> = -1 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#lastIndexOf-5">lastIndexOf</a></b> ( QRegExp &amp; <i>rx</i>, int <i>from</i> = -1 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#left">left</a></b> ( int <i>n</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#leftJustified">leftJustified</a></b> ( int <i>width</i>, QChar <i>fill</i> = QLatin1Char( ' ' ), bool <i>truncate</i> = false ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringRef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#leftRef">leftRef</a></b> ( int <i>n</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#length">length</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#localeAwareCompare-2">localeAwareCompare</a></b> ( const QStringRef &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#localeAwareCompare-4">localeAwareCompare</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#mid">mid</a></b> ( int <i>position</i>, int <i>n</i> = -1 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringRef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#midRef">midRef</a></b> ( int <i>position</i>, int <i>n</i> = -1 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#normalized">normalized</a></b> ( NormalizationForm <i>mode</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#normalized-2">normalized</a></b> ( NormalizationForm <i>mode</i>, QChar::UnicodeVersion <i>version</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#prepend">prepend</a></b> ( const QString &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#prepend-2">prepend</a></b> ( const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#prepend-3">prepend</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#prepend-4">prepend</a></b> ( const char * <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#prepend-5">prepend</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#push_back">push_back</a></b> ( const QString &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#push_back-2">push_back</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#push_front">push_front</a></b> ( const QString &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#push_front-2">push_front</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#remove">remove</a></b> ( int <i>position</i>, int <i>n</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#remove-2">remove</a></b> ( QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#remove-3">remove</a></b> ( const QString &amp; <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#remove-4">remove</a></b> ( const QRegExp &amp; <i>rx</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#repeated">repeated</a></b> ( int <i>times</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace">replace</a></b> ( int <i>position</i>, int <i>n</i>, const QString &amp; <i>after</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-6">replace</a></b> ( int <i>position</i>, int <i>n</i>, const QChar * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-7">replace</a></b> ( int <i>position</i>, int <i>n</i>, QChar <i>after</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-8">replace</a></b> ( const QString &amp; <i>before</i>, const QString &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-9">replace</a></b> ( const QChar * <i>before</i>, int <i>blen</i>, const QChar * <i>after</i>, int <i>alen</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-10">replace</a></b> ( QChar <i>ch</i>, const QString &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-11">replace</a></b> ( QChar <i>before</i>, QChar <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-12">replace</a></b> ( const QLatin1String &amp; <i>before</i>, const QLatin1String &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-13">replace</a></b> ( const QLatin1String &amp; <i>before</i>, const QString &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-14">replace</a></b> ( const QString &amp; <i>before</i>, const QLatin1String &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-15">replace</a></b> ( QChar <i>c</i>, const QLatin1String &amp; <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#replace-16">replace</a></b> ( const QRegExp &amp; <i>rx</i>, const QString &amp; <i>after</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#reserve">reserve</a></b> ( int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#resize">resize</a></b> ( int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#right">right</a></b> ( int <i>n</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#rightJustified">rightJustified</a></b> ( int <i>width</i>, QChar <i>fill</i> = QLatin1Char( ' ' ), bool <i>truncate</i> = false ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringRef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#rightRef">rightRef</a></b> ( int <i>n</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#section">section</a></b> ( QChar <i>sep</i>, int <i>start</i>, int <i>end</i> = -1, SectionFlags <i>flags</i> = SectionDefault ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#section-2">section</a></b> ( const QString &amp; <i>sep</i>, int <i>start</i>, int <i>end</i> = -1, SectionFlags <i>flags</i> = SectionDefault ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#section-3">section</a></b> ( const QRegExp &amp; <i>reg</i>, int <i>start</i>, int <i>end</i> = -1, SectionFlags <i>flags</i> = SectionDefault ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum">setNum</a></b> ( int <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-2">setNum</a></b> ( uint <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-3">setNum</a></b> ( long <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-4">setNum</a></b> ( ulong <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-5">setNum</a></b> ( qlonglong <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-6">setNum</a></b> ( qulonglong <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-7">setNum</a></b> ( short <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-8">setNum</a></b> ( ushort <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-9">setNum</a></b> ( double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setNum-10">setNum</a></b> ( float <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setUnicode">setUnicode</a></b> ( const QChar * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#setUtf16">setUtf16</a></b> ( const ushort * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#simplified">simplified</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringList </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#split">split</a></b> ( const QString &amp; <i>sep</i>, SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringList </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#split-2">split</a></b> ( const QChar &amp; <i>sep</i>, SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringList </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#split-3">split</a></b> ( const QRegExp &amp; <i>rx</i>, SplitBehavior <i>behavior</i> = KeepEmptyParts ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#sprintf">sprintf</a></b> ( const char * <i>cformat</i>, ... )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#squeeze">squeeze</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#startsWith">startsWith</a></b> ( const QString &amp; <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#startsWith-3">startsWith</a></b> ( const QLatin1String &amp; <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#startsWith-4">startsWith</a></b> ( const QChar &amp; <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toAscii">toAscii</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toCaseFolded">toCaseFolded</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toDouble">toDouble</a></b> ( bool * <i>ok</i> = 0 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toFloat">toFloat</a></b> ( bool * <i>ok</i> = 0 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toInt">toInt</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toLatin1">toLatin1</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toLocal8Bit">toLocal8Bit</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toLong">toLong</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">qlonglong </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toLongLong">toLongLong</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toLower">toLower</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toShort">toShort</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toStdString">toStdString</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::wstring </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toStdWString">toStdWString</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toUInt">toUInt</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ulong </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toULong">toULong</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">qulonglong </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toULongLong">toULongLong</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ushort </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toUShort">toUShort</a></b> ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QVector&lt;uint&gt; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toUcs4">toUcs4</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toUpper">toUpper</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toUtf8">toUtf8</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#toWCharArray">toWCharArray</a></b> ( wchar_t * <i>array</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#trimmed">trimmed</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#truncate">truncate</a></b> ( int <i>position</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar * </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#unicode">unicode</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const ushort * </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#utf16">utf16</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#vsprintf">vsprintf</a></b> ( const char * <i>cformat</i>, va_list <i>ap</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-not-eq">operator!=</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-not-eq-2">operator!=</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-not-eq-3">operator!=</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-not-eq-4">operator!=</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq">operator+=</a></b> ( const QString &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-2">operator+=</a></b> ( const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-3">operator+=</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-4">operator+=</a></b> ( const char * <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-5">operator+=</a></b> ( const QStringRef &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-6">operator+=</a></b> ( char <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-eq-7">operator+=</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt">operator&lt;</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-2">operator&lt;</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-3">operator&lt;</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-4">operator&lt;</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-eq">operator&lt;=</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-eq-2">operator&lt;=</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-eq-3">operator&lt;=</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-eq-4">operator&lt;=</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq">operator=</a></b> ( const QString &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-3">operator=</a></b> ( const QLatin1String &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-4">operator=</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-5">operator=</a></b> ( const char * <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-6">operator=</a></b> ( char <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-7">operator=</a></b> ( QChar <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-eq">operator==</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-eq-2">operator==</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-eq-3">operator==</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-eq-4">operator==</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt">operator&gt;</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-2">operator&gt;</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-3">operator&gt;</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-4">operator&gt;</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-eq">operator&gt;=</a></b> ( const QString &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-eq-2">operator&gt;=</a></b> ( const QLatin1String &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-eq-3">operator&gt;=</a></b> ( const QByteArray &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-eq-4">operator&gt;=</a></b> ( const char * <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QCharRef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-5b-5d">operator[]</a></b> ( int <i>position</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-5b-5d-2">operator[]</a></b> ( int <i>position</i> ) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QCharRef </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-5b-5d-3">operator[]</a></b> ( uint <i>position</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QChar </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-5b-5d-4">operator[]</a></b> ( uint <i>position</i> ) const</td></tr>
</table>
<hr />
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare">compare</a></b> ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i>, Qt::CaseSensitivity <i>cs</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-2">compare</a></b> ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-3">compare</a></b> ( const QString &amp; <i>s1</i>, const QLatin1String &amp; <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-4">compare</a></b> ( const QLatin1String &amp; <i>s1</i>, const QString &amp; <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#compare-9">compare</a></b> ( const QString &amp; <i>s1</i>, const QStringRef &amp; <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromAscii">fromAscii</a></b> ( const char * <i>str</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromLatin1">fromLatin1</a></b> ( const char * <i>str</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a></b> ( const char * <i>str</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromRawData">fromRawData</a></b> ( const QChar * <i>unicode</i>, int <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromStdString">fromStdString</a></b> ( const std::string &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromStdWString">fromStdWString</a></b> ( const std::wstring &amp; <i>str</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromUcs4">fromUcs4</a></b> ( const uint * <i>unicode</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromUtf8">fromUtf8</a></b> ( const char * <i>str</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromUtf16">fromUtf16</a></b> ( const ushort * <i>unicode</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#fromWCharArray">fromWCharArray</a></b> ( const wchar_t * <i>string</i>, int <i>size</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#localeAwareCompare">localeAwareCompare</a></b> ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#localeAwareCompare-3">localeAwareCompare</a></b> ( const QString &amp; <i>s1</i>, const QStringRef &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number">number</a></b> ( long <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-2">number</a></b> ( double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-3">number</a></b> ( ulong <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-4">number</a></b> ( int <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-5">number</a></b> ( uint <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-6">number</a></b> ( qlonglong <i>n</i>, int <i>base</i> = 10 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#number-7">number</a></b> ( qulonglong <i>n</i>, int <i>base</i> = 10 )</td></tr>
</table>
<hr />
<a name="related-non-members"></a>
<h2>Related Non-Members</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-not-eq-15">operator!=</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-10">operator+</a></b> ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-13">operator+</a></b> ( const QString &amp; <i>s1</i>, const char * <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-14">operator+</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-15">operator+</a></b> ( char <i>ch</i>, const QString &amp; <i>s</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QString </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-2b-16">operator+</a></b> ( const QString &amp; <i>s</i>, char <i>ch</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-5">operator&lt;</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QDataStream &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-lt-42">operator&lt;&lt;</a></b> ( QDataStream &amp; <i>stream</i>, const QString &amp; <i>string</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-lt-eq-5">operator&lt;=</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-eq-eq-85">operator==</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-5">operator&gt;</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-eq-5">operator&gt;=</a></b> ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QDataStream &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#operator-gt-gt-22">operator&gt;&gt;</a></b> ( QDataStream &amp; <i>stream</i>, QString &amp; <i>string</i> )</td></tr>
</table>
<hr />
<a name="macros"></a>
<h2>Macros</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a></b></td></tr>
</table>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QString class provides a Unicode character string.</p>
<p>QString stores a string of 16-bit <a href="qchar.html">QChar</a>s, where each <a href="qchar.html">QChar</a> corresponds one Unicode 4.0 character. (Unicode characters with code values above 65535 are stored using surrogate pairs, i.e&#x2e;, two consecutive <a href="qchar.html">QChar</a>s.)</p>
<p><a href="unicode.html#unicode">Unicode</a> is an international standard that supports most of the writing systems in use today. It is a superset of ASCII and Latin-1 (ISO 8859-1), and all the ASCII/Latin-1 characters are available at the same code positions.</p>
<p>Behind the scenes, QString uses <a href="implicit-sharing.html">implicit sharing</a> (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.</p>
<p>In addition to QString, Qt also provides the <a href="qbytearray.html">QByteArray</a> class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, QString is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where <a href="qbytearray.html">QByteArray</a> is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g&#x2e;, with <a href="qt-embedded-linux.html">Qt for Embedded Linux</a>).</p>
<ul><li><a href="#initializing-a-string">Initializing a String</a></li>
<li><a href="#manipulating-string-data">Manipulating String Data</a></li>
<li><a href="#querying-string-data">Querying String Data</a></li>
<li><a href="#converting-between-8-bit-strings-and-unicode-strings">Converting Between 8-Bit Strings and Unicode Strings</a></li>
<li><a href="#note-for-c-programmers">Note for C Programmers</a></li>
<li><a href="#distinction-between-null-and-empty-strings">Distinction Between Null and Empty Strings</a></li>
<li><a href="#argument-formats">Argument Formats</a></li>
<li><a href="#more-efficient-string-construction">More Efficient String Construction</a></li>
</ul>
<a name="initializing-a-string"></a>
<h3>Initializing a String</h3>
<p>One way to initialize a QString is simply to pass a <tt>const char *</tt> to its constructor. For example, the following code creates a QString of size 5 containing the data &quot;Hello&quot;:</p>
<pre>     QString str = &quot;Hello&quot;;</pre>
<p>QString converts the <tt>const char *</tt> data into Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function. By default, <a href="qstring.html#fromAscii">fromAscii</a>() treats character above 128 as Latin-1 characters, but this can be changed by calling <a href="qtextcodec.html#setCodecForCStrings">QTextCodec::setCodecForCStrings</a>().</p>
<p>In all of the QString functions that take <tt>const char *</tt> parameters, the <tt>const char *</tt> is interpreted as a classic C-style '\0'-terminated string. It is legal for the <tt>const char *</tt> parameter to be 0.</p>
<p>You can also provide string data as an array of <a href="qchar.html">QChar</a>s:</p>
<pre>     static const QChar data[4] = { 0x0055, 0x006e, 0x10e3, 0x03a3 };
     QString str(data, 4);</pre>
<p>QString makes a deep copy of the <a href="qchar.html">QChar</a> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <a href="qstring.html#fromRawData">QString::fromRawData</a>() instead.)</p>
<p>Another approach is to set the size of the string using <a href="qstring.html#resize">resize</a>() and to initialize the data character per character. QString uses 0-based indexes, just like C++ arrays. To access the character at a particular index position, you can use <a href="qstring.html#operator-5b-5d">operator[]</a>(). On non-const strings, <a href="qstring.html#operator-5b-5d">operator[]</a>() returns a reference to a character that can be used on the left side of an assignment. For example:</p>
<pre>     QString str;
     str.resize(4);

     str[0] = QChar('U');
     str[1] = QChar('n');
     str[2] = QChar(0x10e3);
     str[3] = QChar(0x03a3);</pre>
<p>For read-only access, an alternative syntax is to use the <a href="qstring.html#at">at</a>() function:</p>
<pre>     QString str;

     for (int i = 0; i &lt; str.size(); ++i) {
         if (str.at(i) &gt;= QChar('a') &amp;&amp; str.at(i) &lt;= QChar('f'))
             qDebug() &lt;&lt; &quot;Found character in range [a-f]&quot;;
     }</pre>
<p>The <a href="qstring.html#at">at</a>() function can be faster than <a href="qstring.html#operator-5b-5d">operator[]</a>(), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur. Alternatively, use the <a href="qstring.html#left">left</a>(), <a href="qstring.html#right">right</a>(), or <a href="qstring.html#mid">mid</a>() functions to extract several characters at a time.</p>
<p>A QString can embed '\0' characters (<a href="qchar.html#SpecialCharacter-enum">QChar::Null</a>). The <a href="qstring.html#size">size</a>() function always returns the size of the whole string, including embedded '\0' characters.</p>
<p>After a call to the <a href="qstring.html#resize">resize</a>() function, newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the <a href="qstring.html#fill">fill</a>() function.</p>
<p>QString provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can write code like this and it will work as expected:</p>
<pre>     QString str;

     if (str == &quot;auto&quot; || str == &quot;extern&quot;
             || str == &quot;static&quot; || str == &quot;register&quot;) {
         <span class="comment">// ...</span>
     }</pre>
<p>You can also pass string literals to functions that take QStrings as arguments, invoking the QString(const char *) constructor. Similarly, you can pass a QString to a function that takes a <tt>const char *</tt> argument using the <a href="qtglobal.html#qPrintable">qPrintable</a>() macro which returns the given QString as a <tt>const char *</tt>. This is equivalent to calling &lt;QString&gt;.<a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().<a href="qstring.html#constData">constData</a>().</p>
<a name="manipulating-string-data"></a>
<h3>Manipulating String Data</h3>
<p>QString provides the following basic functions for modifying the character data: <a href="qstring.html#append">append</a>(), <a href="qstring.html#prepend">prepend</a>(), <a href="qstring.html#insert">insert</a>(), <a href="qstring.html#replace">replace</a>(), and <a href="qstring.html#remove">remove</a>(). For example:</p>
<pre>     QString str = &quot;and&quot;;
     str.prepend(&quot;rock &quot;);     <span class="comment">// str == &quot;rock and&quot;</span>
     str.append(&quot; roll&quot;);        <span class="comment">// str == &quot;rock and roll&quot;</span>
     str.replace(5, 3, &quot;&amp;&quot;);   <span class="comment">// str == &quot;rock &amp; roll&quot;</span></pre>
<p>If you are building a QString gradually and know in advance approximately how many characters the QString will contain, you can call <a href="qstring.html#reserve">reserve</a>(), asking QString to preallocate a certain amount of memory. You can also call <a href="qstring.html#capacity">capacity</a>() to find out how much memory QString actually allocated.</p>
<p>The <a href="qstring.html#replace">replace</a>() and <a href="qstring.html#remove">remove</a>() functions' first two arguments are the position from which to start erasing and the number of characters that should be erased. If you want to replace all occurrences of a particular substring with another, use one of the two-parameter <a href="qstring.html#replace">replace</a>() overloads.</p>
<p>A frequent requirement is to remove whitespace characters from a string ('\n', '\t', ' ', etc.)&#x2e; If you want to remove whitespace from both ends of a QString, use the <a href="qstring.html#trimmed">trimmed</a>() function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use <a href="qstring.html#simplified">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or substring in a QString, use the <a href="qstring.html#indexOf">indexOf</a>() or <a href="qstring.html#lastIndexOf">lastIndexOf</a>() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</p>
<pre>     QString str = &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;;
     int j = 0;

     while ((j = str.indexOf(&quot;&lt;b&gt;&quot;, j)) != -1) {
         qDebug() &lt;&lt; &quot;Found &lt;b&gt; tag at index position&quot; &lt;&lt; j;
         ++j;
     }</pre>
<p>QString provides many functions for converting numbers into strings and strings into numbers. See the <a href="qstring.html#arg">arg</a>() functions, the <a href="qstring.html#setNum">setNum</a>() functions, the <a href="qstring.html#number">number</a>() static functions, and the <a href="qstring.html#toInt">toInt</a>(), <a href="qstring.html#toDouble">toDouble</a>(), and similar functions.</p>
<p>To get an upper- or lowercase version of a string use <a href="qstring.html#toUpper">toUpper</a>() or <a href="qstring.html#toLower">toLower</a>().</p>
<p>Lists of strings are handled by the <a href="qstringlist.html">QStringList</a> class. You can split a string into a list of strings using the <a href="qstring.html#split">split</a>() function, and join a list of strings into a single string with an optional separator using <a href="qstringlist.html#join">QStringList::join</a>(). You can obtain a list of strings from a string list that contain a particular substring or that match a particular <a href="qregexp.html">QRegExp</a> using the <a href="qlist-qt3.html#find" class="compat">QStringList::find</a>() function. :</p>
<a name="querying-string-data"></a>
<h3>Querying String Data</h3>
<p>If you want to see if a QString starts or ends with a particular substring use <a href="qstring.html#startsWith">startsWith</a>() or <a href="qstring.html#endsWith">endsWith</a>(). If you simply want to check whether a QString contains a particular character or substring, use the <a href="qstring.html#contains">contains</a>() function. If you want to find out how many times a particular character or substring occurs in the string, use <a href="qstring.html#count">count</a>().</p>
<p>QStrings can be compared using overloaded operators such as <a href="qstring.html#operator-lt">operator&lt;</a>(), <a href="qstring.html#operator-lt-eq">operator&lt;=</a>(), <a href="qstring.html#operator-eq-eq">operator==</a>(), <a href="qstring.html#operator-gt-eq">operator&gt;=</a>(), and so on. Note that the comparison is based exclusively on the numeric Unicode values of the characters. It is very fast, but is not what a human would expect; the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function is a better choice for sorting user-interface strings.</p>
<p>To obtain a pointer to the actual character data, call <a href="qstring.html#data">data</a>() or <a href="qstring.html#constData">constData</a>(). These functions return a pointer to the beginning of the <a href="qchar.html">QChar</a> data. The pointer is guaranteed to remain valid until a non-const function is called on the QString.</p>
<a name="converting-between-8-bit-strings-and-unicode-strings"></a>
<h3>Converting Between 8-Bit Strings and Unicode Strings</h3>
<p>QString provides the following four functions that return a <tt>const char *</tt> version of the string as <a href="qbytearray.html">QByteArray</a>: <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), and <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().</p>
<ul>
<li><a href="qstring.html#toAscii">toAscii</a>() returns an ASCII encoded 8-bit string.</li>
<li><a href="qstring.html#toLatin1">toLatin1</a>() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.</li>
<li><a href="qstring.html#toUtf8">toUtf8</a>() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of ASCII that supports the entire Unicode character set through multibyte sequences.</li>
<li><a href="qstring.html#toLocal8Bit">toLocal8Bit</a>() returns an 8-bit string using the system's local encoding.</li>
</ul>
<p>To convert from one of these encodings, QString provides <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), and <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(). Other encodings are supported through the <a href="qtextcodec.html">QTextCodec</a> class.</p>
<p>As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with <tt>const char *</tt> strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are ASCII or Latin-1, but there is always the risk that an implicit conversion from or to <tt>const char *</tt> is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:</p>
<ul>
<li><tt>QT_NO_CAST_FROM_ASCII</tt> disables automatic conversions from ASCII to Unicode.</li>
<li><tt>QT_NO_CAST_TO_ASCII</tt> disables automatic conversion from QString to ASCII.</li>
</ul>
<p>One way to define these preprocessor symbols globally for your application is to add the following entry to your <a href="qmake-project-files.html">qmake project file</a>:</p>
<pre> DEFINES += QT_NO_CAST_FROM_ASCII \
            QT_NO_CAST_TO_ASCII</pre>
<p>You then need to explicitly call <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), or <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>() to construct a QString from an 8-bit string, or use the lightweight <a href="qlatin1string.html">QLatin1String</a> class, for example:</p>
<pre> QString url = QLatin1String(&quot;http:<span class="comment">//www.unicode.org/&quot;);</span></pre>
<p>Similarly, you must call <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), or <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>() explicitly to convert the QString to an 8-bit string. (Other encodings are supported through the <a href="qtextcodec.html">QTextCodec</a> class.)</p>
<p><table class="generic" width="100 %" align="center" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><td><a name="note-for-c-programmers"></a>
<h3>Note for C Programmers</h3>
<p>Due to C++'s type system and the fact that QString is <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>, QStrings may be treated like <tt>int</tt>s or other basic types. For example:</p>
<pre>     QString Widget::boolToString(bool b)
     {
         QString result;
         if (b)
             result = &quot;True&quot;;
         else
             result = &quot;False&quot;;
         return result;
     }</pre>
<p>The <tt>result</tt> variable, is a normal variable allocated on the stack. When <tt>return</tt> is called, and because we're returning by value, the copy constructor is called and a copy of the string is returned. No actual copying takes place thanks to the implicit sharing.</p>
</td></tr>
</table></p>
<a name="distinction-between-null-and-empty-strings"></a>
<h3>Distinction Between Null and Empty Strings</h3>
<p>For historical reasons, QString distinguishes between a null string and an empty string. A <i>null</i> string is a string that is initialized using QString's default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> string is any string with size 0. A null string is always empty, but an empty string isn't necessarily null:</p>
<pre>     QString().isNull();               <span class="comment">// returns true</span>
     QString().isEmpty();              <span class="comment">// returns true</span>

     QString(&quot;&quot;).isNull();             <span class="comment">// returns false</span>
     QString(&quot;&quot;).isEmpty();            <span class="comment">// returns true</span>

     QString(&quot;abc&quot;).isNull();          <span class="comment">// returns false</span>
     QString(&quot;abc&quot;).isEmpty();         <span class="comment">// returns false</span></pre>
<p>All functions except <a href="qstring.html#isNull">isNull</a>() treat null strings the same as empty strings. For example, <a href="qstring.html#toAscii">toAscii</a>().<a href="qstring.html#constData">constData</a>() returns a pointer to a '\0' character for a null string (<i>not</i> a null pointer), and <a href="qstring.html#QString">QString</a>() compares equal to QString(&quot;&quot;). We recommend that you always use the <a href="qstring.html#isEmpty">isEmpty</a>() function and avoid <a href="qstring.html#isNull">isNull</a>().</p>
<a name="argument-formats"></a>
<h3>Argument Formats</h3>
<p>In member functions where an argument <i>format</i> can be specified (e.g&#x2e;, <a href="qstring.html#arg">arg</a>(), <a href="qstring.html#number">number</a>()), the argument <i>format</i> can be one of the following:</p>
<p><table class="generic" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Format</th><th>Meaning</th></tr></thead>
<tr valign="top" class="odd"><td><tt>e</tt></td><td>format as [-]9.9e[+|-]999</td></tr>
<tr valign="top" class="even"><td><tt>E</tt></td><td>format as [-]9.9E[+|-]999</td></tr>
<tr valign="top" class="odd"><td><tt>f</tt></td><td>format as [-]9.9</td></tr>
<tr valign="top" class="even"><td><tt>g</tt></td><td>use <tt>e</tt> or <tt>f</tt> format, whichever is the most concise</td></tr>
<tr valign="top" class="odd"><td><tt>G</tt></td><td>use <tt>E</tt> or <tt>f</tt> format, whichever is the most concise</td></tr>
</table></p>
<p>A <i>precision</i> is also specified with the argument <i>format</i>. For the 'e', 'E', and 'f' formats, the <i>precision</i> represents the number of digits <i>after</i> the decimal point. For the 'g' and 'G' formats, the <i>precision</i> represents the maximum number of significant digits (trailing zeroes are omitted).</p>
<a name="more-efficient-string-construction"></a>
<h3>More Efficient String Construction</h3>
<p>Using the QString <tt>'+'</tt> operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:</p>
<pre>     QString foo;
     QString type = &quot;long&quot;;

     foo-&gt;setText(QLatin1String(&quot;vector&lt;&quot;) + type + QLatin1String(&quot;&gt;::iterator&quot;));

     if (foo.startsWith(&quot;(&quot; + type + &quot;) 0x&quot;))
         ...</pre>
<p>There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.</p>
<p>First, multiple uses of the <tt>'+'</tt> operator usually means multiple memory allocations. When concatenating <i>n</i> substrings, where <i>n &gt; 2</i>, there can be as many as <i>n - 1</i> calls to the memory allocator.</p>
<p>Second, <a href="qlatin1string.html">QLatin1String</a> does not store its length internally but calls <a href="qbytearray.html#qstrlen">qstrlen</a>() when it needs to know its length.</p>
<p>In 4.6, an internal template class <tt>QStringBuilder</tt> has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in <tt>src/corelib/tools/qstringbuilder.cpp</tt> if you want to have a look at it.</p>
<p><tt>QStringBuilder</tt> uses expression templates and reimplements the <tt>'%'</tt> operator so that when you use <tt>'%'</tt> for string concatenation instead of <tt>'+'</tt>, multiple substring concatenations will be postponed until the final result is about to be assigned to a QString. At this point, the amount of memory required for the final result is known. The memory allocator is then called <i>once</i> to get the required space, and the substrings are copied into it one by one.</p>
<p><tt>QLatin1Literal</tt> is a second internal class that can replace <a href="qlatin1string.html">QLatin1String</a>, which can't be changed for compatibility reasons. <tt>QLatin1Literal</tt> stores its length, thereby saving time when <tt>QStringBuilder</tt> computes the amount of memory required for the final string.</p>
<p>Additional efficiency is gained by inlining and reduced reference counting (the QString created from a <tt>QStringBuilder</tt> typically has a ref count of 1, whereas <a href="qstring.html#append">QString::append</a>() needs an extra test).</p>
<p>There are three ways you can access this improved method of string construction. The straightforward way is to include <tt>QStringBuilder</tt> wherever you want to use it, and use the <tt>'%'</tt> operator instead of <tt>'+'</tt> when concatenating strings:</p>
<pre>     #include &lt;QStringBuilder&gt;

     QString hello(&quot;hello&quot;);
     QStringRef el(&amp;hello, 2, 3);
     QLatin1String world(&quot;world&quot;);
     QString message =  hello % el % world % QChar('!');</pre>
<p>A more global approach is to include this define:</p>
<pre>     #define QT_USE_FAST_CONCATENATION</pre>
<p>and use <tt>'%'</tt> instead of <tt>'+'</tt> for string concatenation everywhere. The third approach, which is the most convenient but not entirely source compatible, is to include two defines:</p>
<pre>     #define QT_USE_FAST_CONCATENATION
     #define QT_USE_FAST_OPERATOR_PLUS</pre>
<p>and the <tt>'+'</tt> will automatically be performed as the <tt>QStringBuilder</tt> <tt>'%'</tt> everywhere.</p>
<p>See also <a href="qstring.html#fromRawData">fromRawData</a>(), <a href="qchar.html">QChar</a>, <a href="qlatin1string.html">QLatin1String</a>, <a href="qbytearray.html">QByteArray</a>, and <a href="qstringref.html">QStringRef</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<a name="//apple_ref/cpp/tdef/QString/ConstIterator" />
<h3 class="fn"><a name="ConstIterator-typedef"></a>typedef QString::ConstIterator</h3>
<p>Qt-style synonym for <a href="qstring.html#const_iterator-typedef">QString::const_iterator</a>.</p>
<a name="//apple_ref/cpp/tdef/QString/Iterator" />
<h3 class="fn"><a name="Iterator-typedef"></a>typedef QString::Iterator</h3>
<p>Qt-style synonym for <a href="qstring.html#iterator-typedefx">QString::iterator</a>.</p>
<a name="//apple_ref/cpp/tag/QString/NormalizationForm" />
<a name="//apple_ref/cpp/econst/QString/NormalizationForm_D" />
<a name="//apple_ref/cpp/econst/QString/NormalizationForm_C" />
<a name="//apple_ref/cpp/econst/QString/NormalizationForm_KD" />
<a name="//apple_ref/cpp/econst/QString/NormalizationForm_KC" />
<h3 class="fn"><a name="NormalizationForm-enum"></a>enum QString::NormalizationForm</h3>
<p>This enum describes the various normalized forms of Unicode text.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QString::NormalizationForm_D</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">Canonical Decomposition</td></tr>
<tr><td valign="top"><tt>QString::NormalizationForm_C</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">Canonical Decomposition followed by Canonical Composition</td></tr>
<tr><td valign="top"><tt>QString::NormalizationForm_KD</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">Compatibility Decomposition</td></tr>
<tr><td valign="top"><tt>QString::NormalizationForm_KC</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">Compatibility Decomposition followed by Canonical Composition</td></tr>
</table></p>
<p>See also <a href="qstring.html#normalized">normalized</a>() and <a href="http://www.unicode.org/reports/tr15/">Unicode Standard Annex #15</a>.</p>
<a name="//apple_ref/cpp/tag/QString/SectionFlag" />
<a name="//apple_ref/cpp/econst/QString/SectionDefault" />
<a name="//apple_ref/cpp/econst/QString/SectionSkipEmpty" />
<a name="//apple_ref/cpp/econst/QString/SectionIncludeLeadingSep" />
<a name="//apple_ref/cpp/econst/QString/SectionIncludeTrailingSep" />
<a name="//apple_ref/cpp/econst/QString/SectionCaseInsensitiveSeps" />
<a name="//apple_ref/cpp/tdef/QString/SectionFlags" />
<h3 class="flags"><a name="SectionFlag-enum"></a>enum QString::SectionFlag<br />flags QString::SectionFlags</h3>
<p>This enum specifies flags that can be used to affect various aspects of the <a href="qstring.html#section">section</a>() function's behavior with respect to separators and empty fields.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QString::SectionDefault</tt></td><td align="center" valign="top"><tt>0x00</tt></td><td valign="top">Empty fields are counted, leading and trailing separators are not included, and the separator is compared case sensitively.</td></tr>
<tr><td valign="top"><tt>QString::SectionSkipEmpty</tt></td><td align="center" valign="top"><tt>0x01</tt></td><td valign="top">Treat empty fields as if they don't exist, i.e&#x2e; they are not considered as far as <i>start</i> and <i>end</i> are concerned.</td></tr>
<tr><td valign="top"><tt>QString::SectionIncludeLeadingSep</tt></td><td align="center" valign="top"><tt>0x02</tt></td><td valign="top">Include the leading separator (if any) in the result string.</td></tr>
<tr><td valign="top"><tt>QString::SectionIncludeTrailingSep</tt></td><td align="center" valign="top"><tt>0x04</tt></td><td valign="top">Include the trailing separator (if any) in the result string.</td></tr>
<tr><td valign="top"><tt>QString::SectionCaseInsensitiveSeps</tt></td><td align="center" valign="top"><tt>0x08</tt></td><td valign="top">Compare the separator case-insensitively.</td></tr>
</table></p>
<p>The SectionFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;SectionFlag&gt;. It stores an OR combination of SectionFlag values.</p>
<p>See also <a href="qstring.html#section">section</a>().</p>
<a name="//apple_ref/cpp/tag/QString/SplitBehavior" />
<a name="//apple_ref/cpp/econst/QString/KeepEmptyParts" />
<a name="//apple_ref/cpp/econst/QString/SkipEmptyParts" />
<h3 class="fn"><a name="SplitBehavior-enum"></a>enum QString::SplitBehavior</h3>
<p>This enum specifies how the <a href="qstring.html#split">split</a>() function should behave with respect to empty strings.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QString::KeepEmptyParts</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">If a field is empty, keep it in the result.</td></tr>
<tr><td valign="top"><tt>QString::SkipEmptyParts</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">If a field is empty, don't include it in the result.</td></tr>
</table></p>
<p>See also <a href="qstring.html#split">split</a>().</p>
<a name="//apple_ref/cpp/tdef/QString/const_iterator" />
<h3 class="fn"><a name="const_iterator-typedef"></a>typedef QString::const_iterator</h3>
<p>The QString::const_iterator typedef provides an STL-style const iterator for <a href="qstring.html">QString</a>.</p>
<p>See also <a href="qstring.html#iterator-typedefx">QString::iterator</a>.</p>
<a name="//apple_ref/cpp/tdef/QString/iterator" />
<h3 class="fn"><a name="iterator-typedefx"></a>typedef QString::iterator</h3>
<p>The QString::iterator typedef provides an STL-style non-const iterator for <a href="qstring.html">QString</a>.</p>
<p>See also <a href="qstring.html#const_iterator-typedef">QString::const_iterator</a>.</p>
<hr />
<h2>Member Function Documentation</h2>
<a name="//apple_ref/cpp/instm/QString/QString" />
<h3 class="fn"><a name="QString"></a>QString::QString ()</h3>
<p>Constructs a null string. Null strings are also empty.</p>
<p>See also <a href="qstring.html#isEmpty">isEmpty</a>().</p>
<h3 class="fn"><a name="QString-2"></a>QString::QString ( const <a href="qchar.html">QChar</a> * <i>unicode</i>, int <i>size</i> )</h3>
<p>Constructs a string initialized with the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i>.</p>
<p><a href="qstring.html">QString</a> makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.</p>
<h3 class="fn"><a name="QString-3"></a>QString::QString ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>Constructs a string of size 1 containing the character <i>ch</i>.</p>
<h3 class="fn"><a name="QString-4"></a>QString::QString ( int <i>size</i>, <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>Constructs a string of the given <i>size</i> with every character set to <i>ch</i>.</p>
<p>See also <a href="qstring.html#fill">fill</a>().</p>
<h3 class="fn"><a name="QString-5"></a>QString::QString ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>Constructs a copy of the Latin-1 string <i>str</i>.</p>
<p>See also <a href="qstring.html#fromLatin1">fromLatin1</a>().</p>
<h3 class="fn"><a name="QString-6"></a>QString::QString ( const QString &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time">constant time</a>, because <a href="qstring.html">QString</a> is <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>. This makes returning a <a href="qstring.html">QString</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#linear-time">linear time</a>.</p>
<p>See also <a href="qstring.html#operator-eq">operator=</a>().</p>
<h3 class="fn"><a name="QString-7"></a>QString::QString ( const char * <i>str</i> )</h3>
<p>Constructs a string initialized with the ASCII string <i>str</i>. The given const char pointer is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this constructor by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<p>See also <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<h3 class="fn"><a name="QString-8"></a>QString::QString ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>Constructs a string initialized with the byte array <i>ba</i>. The given byte array is converted to Unicode using <a href="qstring.html#fromAscii">fromAscii</a>(). Stops copying at the first 0 character, otherwise copies the entire byte array.</p>
<p>You can disable this constructor by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<p>See also <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<a name="//apple_ref/cpp/instm/QString/~QString" />
<h3 class="fn"><a name="dtor.QString"></a>QString::~QString ()</h3>
<p>Destroys the string.</p>
<a name="//apple_ref/cpp/instm/QString/append" />
<h3 class="fn"><a name="append"></a>QString &amp; QString::append ( const QString &amp; <i>str</i> )</h3>
<p>Appends the string <i>str</i> onto the end of this string.</p>
<p>Example:</p>
<pre>     QString x = &quot;free&quot;;
     QString y = &quot;dom&quot;;

     x.append(y);
     <span class="comment">// x == &quot;freedom&quot;</span></pre>
<p>This is the same as using the <a href="qstring.html#insert">insert</a>() function:</p>
<pre>     x.insert(x.size(), y);</pre>
<p>The append() function is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qstring.html">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p>See also <a href="qstring.html#operator-2b-eq">operator+=</a>(), <a href="qstring.html#prepend">prepend</a>(), and <a href="qstring.html#insert">insert</a>().</p>
<h3 class="fn"><a name="append-2"></a>QString &amp; QString::append ( const <a href="qstringref.html">QStringRef</a> &amp; <i>reference</i> )</h3>
<p>Appends the given string <i>reference</i> to this string and returns the result.</p>
<p>This function was introduced in Qt 4.4.</p>
<h3 class="fn"><a name="append-3"></a>QString &amp; QString::append ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#append">append</a>().</p>
<p>Appends the Latin-1 string <i>str</i> to this string.</p>
<h3 class="fn"><a name="append-4"></a>QString &amp; QString::append ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This function overloads <a href="qstring.html#append">append</a>().</p>
<p>Appends the byte array <i>ba</i> to this string. The given byte array is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="append-5"></a>QString &amp; QString::append ( const char * <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#append">append</a>().</p>
<p>Appends the string <i>str</i> to this string. The given const char pointer is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="append-6"></a>QString &amp; QString::append ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#append">append</a>().</p>
<p>Appends the character <i>ch</i> to this string.</p>
<a name="//apple_ref/cpp/instm/QString/arg" />
<h3 class="fn"><a name="arg"></a>QString QString::arg ( const QString &amp; <i>a</i>, int <i>fieldWidth</i> = 0, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>Returns a copy of this string with the lowest numbered place marker replaced by string <i>a</i>, i.e&#x2e;, <tt>%1</tt>, <tt>%2</tt>, ..&#x2e;, <tt>%99</tt>.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that argument <i>a</i> shall occupy. If <i>a</i> requires less space than <i>fieldWidth</i>, it is padded to <i>fieldWidth</i> with character <i>fillChar</i>. A positive <i>fieldWidth</i> produces right-aligned text. A negative <i>fieldWidth</i> produces left-aligned text.</p>
<p>This example shows how we might create a <tt>status</tt> string for reporting progress while processing a list of files:</p>
<pre>     QString i;           <span class="comment">// current file's number</span>
     QString total;       <span class="comment">// number of files to process</span>
     QString fileName;    <span class="comment">// current file's name</span>

     QString status = QString(&quot;Processing file %1 of %2: %3&quot;)
                     .arg(i).arg(total).arg(fileName);</pre>
<p>First, <tt>arg(i)</tt> replaces <tt>%1</tt>. Then <tt>arg(total)</tt> replaces <tt>%2</tt>. Finally, <tt>arg(fileName)</tt> replaces <tt>%3</tt>.</p>
<p>One advantage of using arg() over <a href="qstring.html#sprintf">sprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker <tt>%i</tt> appears more than once in the string, the arg() replaces all of them.</p>
<p>If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.</p>
<h3 class="fn"><a name="arg-2"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as <tt>str.arg(a1).arg(a2)</tt>, except that the strings <i>a1</i> and <i>a2</i> are replaced in one pass. This can make a difference if <i>a1</i> contains e.g&#x2e; <tt>%1</tt>:</p>
<pre>     QString str;
     str = &quot;%1 %2&quot;;

     str.arg(&quot;%1f&quot;, &quot;Hello&quot;);        <span class="comment">// returns &quot;%1f Hello&quot;</span>
     str.arg(&quot;%1f&quot;).arg(&quot;Hello&quot;);    <span class="comment">// returns &quot;Hellof %2&quot;</span></pre>
<h3 class="fn"><a name="arg-3"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3)</tt>, except that the strings <i>a1</i>, <i>a2</i> and <i>a3</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-4"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i> and <i>a4</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-5"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, and <i>a5</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-6"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, and <i>a6</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-7"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, and <i>a7</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-8"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i>, const QString &amp; <i>a8</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, and <i>a8</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-9"></a>QString QString::arg ( const QString &amp; <i>a1</i>, const QString &amp; <i>a2</i>, const QString &amp; <i>a3</i>, const QString &amp; <i>a4</i>, const QString &amp; <i>a5</i>, const QString &amp; <i>a6</i>, const QString &amp; <i>a7</i>, const QString &amp; <i>a8</i>, const QString &amp; <i>a9</i> ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, <i>a8</i>, and <i>a9</i> are replaced in one pass.</p>
<h3 class="fn"><a name="arg-10"></a>QString QString::arg ( int <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>a</i> argument is expressed in base <i>base</i>, which is 10 by default and must be between 2 and 36. For bases other than 10, <i>a</i> is treated as an unsigned integer.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). If no default locale was specified, the &quot;C&quot; locale is used. The 'L' flag is ignored if <i>base</i> is not 10.</p>
<pre>     QString str;
     str = QString(&quot;Decimal 63 is %1 in hexadecimal&quot;)
             .arg(63, 0, 16);
     <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

     QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
     str = QString(&quot;%1 %L2 %L3&quot;)
             .arg(12345)
             .arg(12345)
             .arg(12345, 0, 16);
     <span class="comment">// str == &quot;12345 12,345 3039&quot;</span></pre>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-11"></a>QString QString::arg ( <a href="qtglobal.html#uint-typedef">uint</a> <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-12"></a>QString QString::arg ( long <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>a</i> argument is expressed in the given <i>base</i>, which is 10 by default and must be between 2 and 36.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). The 'L' flag is ignored if <i>base</i> is not 10.</p>
<pre>     QString str;
     str = QString(&quot;Decimal 63 is %1 in hexadecimal&quot;)
             .arg(63, 0, 16);
     <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

     QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
     str = QString(&quot;%1 %L2 %L3&quot;)
             .arg(12345)
             .arg(12345)
             .arg(12345, 0, 16);
     <span class="comment">// str == &quot;12345 12,345 3039&quot;</span></pre>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-13"></a>QString QString::arg ( <a href="qtglobal.html#ulong-typedef">ulong</a> <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> to a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-14"></a>QString QString::arg ( <a href="qtglobal.html#qlonglong-typedef">qlonglong</a> <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-15"></a>QString QString::arg ( <a href="qtglobal.html#qulonglong-typedef">qulonglong</a> <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. <i>base</i> must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-16"></a>QString QString::arg ( short <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-17"></a>QString QString::arg ( <a href="qtglobal.html#ushort-typedef">ushort</a> <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<h3 class="fn"><a name="arg-18"></a>QString QString::arg ( <a href="qchar.html">QChar</a> <i>a</i>, int <i>fieldWidth</i> = 0, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<h3 class="fn"><a name="arg-19"></a>QString QString::arg ( char <i>a</i>, int <i>fieldWidth</i> = 0, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>a</i> argument is interpreted as a Latin-1 character.</p>
<h3 class="fn"><a name="arg-20"></a>QString QString::arg ( double <i>a</i>, int <i>fieldWidth</i> = 0, char <i>format</i> = 'g', int <i>precision</i> = -1, const <a href="qchar.html">QChar</a> &amp; <i>fillChar</i> = QLatin1Char( ' ' ) ) const</h3>
<p>This function overloads <a href="qstring.html#arg">arg</a>().</p>
<p>Argument <i>a</i> is formatted according to the specified <i>format</i> and <i>precision</i>. See <a href="qstring.html#argument-formats">Argument Formats</a> for details.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<pre> double d = 12.34;
 QString str = QString(&quot;delta: %1&quot;).arg(d, 0, 'E', 3);
<span class="comment"> // str == &quot;delta: 1.234E+01&quot;</span></pre>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by QLocale::setDefaultLocale(). If no default locale was specified, the &quot;C&quot; locale is used.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), this function will use the locale's zero to pad. For negative numbers, the zero padding will probably appear before the minus sign.</p>
<p>See also <a href="qlocale.html#toString">QLocale::toString</a>().</p>
<a name="//apple_ref/cpp/instm/QString/at" />
<h3 class="fn"><a name="at"></a>const <a href="qchar.html">QChar</a> QString::at ( int <i>position</i> ) const</h3>
<p>Returns the character at the given index <i>position</i> in the string.</p>
<p>The <i>position</i> must be a valid index position in the string (i.e&#x2e;, 0 &lt;= <i>position</i> &lt; <a href="qstring.html#size">size</a>()).</p>
<p>See also <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<a name="//apple_ref/cpp/instm/QString/begin" />
<h3 class="fn"><a name="begin"></a><a href="qstring.html#iterator-typedefx">iterator</a> QString::begin ()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first character in the string.</p>
<p>See also <a href="qstring.html#constBegin">constBegin</a>() and <a href="qstring.html#end">end</a>().</p>
<h3 class="fn"><a name="begin-2"></a><a href="qstring.html#const_iterator-typedef">const_iterator</a> QString::begin () const</h3>
<p>This function overloads <a href="qstring.html#begin">begin</a>().</p>
<a name="//apple_ref/cpp/instm/QString/capacity" />
<h3 class="fn"><a name="capacity"></a>int QString::capacity () const</h3>
<p>Returns the maximum number of characters that can be stored in the string without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call <a href="qstring.html#size">size</a>().</p>
<p>See also <a href="qstring.html#reserve">reserve</a>() and <a href="qstring.html#squeeze">squeeze</a>().</p>
<a name="//apple_ref/cpp/instm/QString/chop" />
<h3 class="fn"><a name="chop"></a>void QString::chop ( int <i>n</i> )</h3>
<p>Removes <i>n</i> characters from the end of the string.</p>
<p>If <i>n</i> is greater than <a href="qstring.html#size">size</a>(), the result is an empty string.</p>
<p>Example:</p>
<pre>     QString str(&quot;LOGOUT\r\n&quot;);
     str.chop(2);
     <span class="comment">// str == &quot;LOGOUT&quot;</span></pre>
<p>If you want to remove characters from the <i>beginning</i> of the string, use <a href="qstring.html#remove">remove</a>() instead.</p>
<p>See also <a href="qstring.html#truncate">truncate</a>(), <a href="qstring.html#resize">resize</a>(), and <a href="qstring.html#remove">remove</a>().</p>
<a name="//apple_ref/cpp/instm/QString/clear" />
<h3 class="fn"><a name="clear"></a>void QString::clear ()</h3>
<p>Clears the contents of the string and makes it empty.</p>
<p>See also <a href="qstring.html#resize">resize</a>() and <a href="qstring.html#isEmpty">isEmpty</a>().</p>
<a name="//apple_ref/cpp/clm/QString/compare" />
<h3 class="fn"><a name="compare"></a>int QString::compare ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>, the comparison is case sensitive; otherwise the comparison is case insensitive.</p>
<p>Case sensitive comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-visible strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<pre>     int x = QString::compare(&quot;aUtO&quot;, &quot;AuTo&quot;, Qt::CaseInsensitive);  <span class="comment">// x == 0</span>
     int y = QString::compare(&quot;auto&quot;, &quot;Car&quot;, Qt::CaseSensitive);     <span class="comment">// y &gt; 0</span>
     int z = QString::compare(&quot;auto&quot;, &quot;Car&quot;, Qt::CaseInsensitive);   <span class="comment">// z &lt; 0</span></pre>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qstring.html#operator-eq-eq">operator==</a>(), <a href="qstring.html#operator-lt">operator&lt;</a>(), and <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<h3 class="fn"><a name="compare-2"></a>int QString::compare ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a case sensitive compare of <i>s1</i> and <i>s2</i>.</p>
<h3 class="fn"><a name="compare-3"></a>int QString::compare ( const QString &amp; <i>s1</i>, const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>s2</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="compare-4"></a>int QString::compare ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>s1</i>, const QString &amp; <i>s2</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="compare-5"></a>int QString::compare ( const QString &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Lexically compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.</p>
<p>Equivalent to <tt>compare(*this, other)</tt>.</p>
<h3 class="fn"><a name="compare-6"></a>int QString::compare ( const QString &amp; <i>other</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> ) const</h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Same as compare(*this, <i>other</i>, <i>cs</i>).</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="compare-7"></a>int QString::compare ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Same as compare(*this, <i>other</i>, <i>cs</i>).</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="compare-8"></a>int QString::compare ( const <a href="qstringref.html">QStringRef</a> &amp; <i>ref</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<p>Compares the string reference, <i>ref</i>, with the string and returns an integer less than, equal to, or greater than zero if the string is less than, equal to, or greater than <i>ref</i>.</p>
<h3 class="fn"><a name="compare-9"></a>int QString::compare ( const QString &amp; <i>s1</i>, const <a href="qstringref.html">QStringRef</a> &amp; <i>s2</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This function overloads <a href="qstring.html#compare">compare</a>().</p>
<a name="//apple_ref/cpp/instm/QString/constBegin" />
<h3 class="fn"><a name="constBegin"></a><a href="qstring.html#const_iterator-typedef">const_iterator</a> QString::constBegin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first character in the string.</p>
<p>See also <a href="qstring.html#begin">begin</a>() and <a href="qstring.html#constEnd">constEnd</a>().</p>
<a name="//apple_ref/cpp/instm/QString/constData" />
<h3 class="fn"><a name="constData"></a>const <a href="qchar.html">QChar</a> * QString::constData () const</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html">QString</a>. The pointer can be used to access the characters that compose the string. For convenience, the data is '\0'-terminated.</p>
<p>Note that the pointer remains valid only as long as the string is not modified.</p>
<p>See also <a href="qstring.html#data">data</a>() and <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<a name="//apple_ref/cpp/instm/QString/constEnd" />
<h3 class="fn"><a name="constEnd"></a><a href="qstring.html#const_iterator-typedef">const_iterator</a> QString::constEnd () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the list.</p>
<p>See also <a href="qstring.html#constBegin">constBegin</a>() and <a href="qstring.html#end">end</a>().</p>
<a name="//apple_ref/cpp/instm/QString/contains" />
<h3 class="fn"><a name="contains"></a>bool QString::contains ( const QString &amp; <i>str</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns true if this string contains an occurrence of the string <i>str</i>; otherwise returns false.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString str = &quot;Peter Pan&quot;;
     str.contains(&quot;peter&quot;, Qt::CaseInsensitive);    <span class="comment">// returns true</span></pre>
<p>See also <a href="qstring.html#indexOf">indexOf</a>() and <a href="qstring.html#count">count</a>().</p>
<h3 class="fn"><a name="contains-4"></a>bool QString::contains ( <a href="qchar.html">QChar</a> <i>ch</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#contains">contains</a>().</p>
<p>Returns true if this string contains an occurrence of the character <i>ch</i>; otherwise returns false.</p>
<h3 class="fn"><a name="contains-5"></a>bool QString::contains ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i> ) const</h3>
<p>This function overloads <a href="qstring.html#contains">contains</a>().</p>
<p>Returns true if the regular expression <i>rx</i> matches somewhere in this string; otherwise returns false.</p>
<h3 class="fn"><a name="contains-6"></a>bool QString::contains ( <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i> ) const</h3>
<p>This function overloads <a href="qstring.html#contains">contains</a>().</p>
<p>Returns true if the regular expression <i>rx</i> matches somewhere in this string; otherwise returns false.</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).</p>
<p>This function was introduced in Qt 4.5.</p>
<a name="//apple_ref/cpp/instm/QString/count" />
<h3 class="fn"><a name="count"></a>int QString::count ( const QString &amp; <i>str</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of the string <i>str</i> in this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>See also <a href="qstring.html#contains">contains</a>() and <a href="qstring.html#indexOf">indexOf</a>().</p>
<h3 class="fn"><a name="count-2"></a>int QString::count ( <a href="qchar.html">QChar</a> <i>ch</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#count">count</a>().</p>
<p>Returns the number of occurrences of character <i>ch</i> in the string.</p>
<h3 class="fn"><a name="count-3"></a>int QString::count ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i> ) const</h3>
<p>This function overloads <a href="qstring.html#count">count</a>().</p>
<p>Returns the number of times the regular expression <i>rx</i> matches in the string.</p>
<p>This function counts overlapping matches, so in the example below, there are four instances of &quot;ana&quot; or &quot;ama&quot;:</p>
<pre>     QString str = &quot;banana and panama&quot;;
     str.count(QRegExp(&quot;a[nm]a&quot;));    <span class="comment">// returns 4</span></pre>
<h3 class="fn"><a name="count-4"></a>int QString::count () const</h3>
<p>This function overloads <a href="qstring.html#count">count</a>().</p>
<p>Same as <a href="qstring.html#size">size</a>().</p>
<a name="//apple_ref/cpp/instm/QString/data" />
<h3 class="fn"><a name="data"></a><a href="qchar.html">QChar</a> * QString::data ()</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html">QString</a>. The pointer can be used to access and modify the characters that compose the string. For convenience, the data is '\0'-terminated.</p>
<p>Example:</p>
<pre>     QString str = &quot;Hello world&quot;;
     QChar *data = str.data();
     while (!data-&gt;isNull()) {
         qDebug() &lt;&lt; data-&gt;unicode();
         ++data;
     }</pre>
<p>Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, <a href="qstring.html#constData">constData</a>() is faster because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>See also <a href="qstring.html#constData">constData</a>() and <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<h3 class="fn"><a name="data-2"></a>const <a href="qchar.html">QChar</a> * QString::data () const</h3>
<p>This is an overloaded function.</p>
<a name="//apple_ref/cpp/instm/QString/end" />
<h3 class="fn"><a name="end"></a><a href="qstring.html#iterator-typedefx">iterator</a> QString::end ()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary character after the last character in the string.</p>
<p>See also <a href="qstring.html#begin">begin</a>() and <a href="qstring.html#constEnd">constEnd</a>().</p>
<h3 class="fn"><a name="end-2"></a><a href="qstring.html#const_iterator-typedef">const_iterator</a> QString::end () const</h3>
<p>This function overloads <a href="qstring.html#end">end</a>().</p>
<a name="//apple_ref/cpp/instm/QString/endsWith" />
<h3 class="fn"><a name="endsWith"></a>bool QString::endsWith ( const QString &amp; <i>s</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns true if the string ends with <i>s</i>; otherwise returns false.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<pre>     QString str = &quot;Bananas&quot;;
     str.endsWith(&quot;anas&quot;);         <span class="comment">// returns true</span>
     str.endsWith(&quot;pple&quot;);         <span class="comment">// returns false</span></pre>
<p>See also <a href="qstring.html#startsWith">startsWith</a>().</p>
<h3 class="fn"><a name="endsWith-3"></a>bool QString::endsWith ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>s</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#endsWith">endsWith</a>().</p>
<h3 class="fn"><a name="endsWith-4"></a>bool QString::endsWith ( const <a href="qchar.html">QChar</a> &amp; <i>c</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns true if the string ends with <i>c</i>; otherwise returns false.</p>
<p>This function overloads <a href="qstring.html#endsWith">endsWith</a>().</p>
<a name="//apple_ref/cpp/instm/QString/fill" />
<h3 class="fn"><a name="fill"></a>QString &amp; QString::fill ( <a href="qchar.html">QChar</a> <i>ch</i>, int <i>size</i> = -1 )</h3>
<p>Sets every character in the string to character <i>ch</i>. If <i>size</i> is different from -1 (default), the string is resized to <i>size</i> beforehand.</p>
<p>Example:</p>
<pre>     QString str = &quot;Berlin&quot;;
     str.fill('z');
     <span class="comment">// str == &quot;zzzzzz&quot;</span>

     str.fill('A', 2);
     <span class="comment">// str == &quot;AA&quot;</span></pre>
<p>See also <a href="qstring.html#resize">resize</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromAscii" />
<h3 class="fn"><a name="fromAscii"></a>QString QString::fromAscii ( const char * <i>str</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the 8-bit ASCII string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).</p>
<p>If a codec has been set using <a href="qtextcodec.html#setCodecForCStrings">QTextCodec::setCodecForCStrings</a>(), it is used to convert <i>str</i> to Unicode; otherwise this function does the same as <a href="qstring.html#fromLatin1">fromLatin1</a>().</p>
<p>See also <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), and <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromLatin1" />
<h3 class="fn"><a name="fromLatin1"></a>QString QString::fromLatin1 ( const char * <i>str</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Latin-1 string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).</p>
<p>See also <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), and <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromLocal8Bit" />
<h3 class="fn"><a name="fromLocal8Bit"></a>QString QString::fromLocal8Bit ( const char * <i>str</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the 8-bit string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).</p>
<p><a href="qtextcodec.html#codecForLocale">QTextCodec::codecForLocale</a>() is used to perform the conversion from Unicode.</p>
<p>See also <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), and <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromRawData" />
<h3 class="fn"><a name="fromRawData"></a>QString QString::fromRawData ( const <a href="qchar.html">QChar</a> * <i>unicode</i>, int <i>size</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Constructs a <a href="qstring.html">QString</a> that uses the first <i>size</i> Unicode characters in the array <i>unicode</i>. The data in <i>unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i>unicode</i> will not be deleted or modified as long as the <a href="qstring.html">QString</a> (or an unmodified copy of it) exists.</p>
<p>Any attempts to modify the <a href="qstring.html">QString</a> or copies of it will cause it to create a deep copy of the data, ensuring that the raw data isn't modified.</p>
<p>Here's an example of how we can use a <a href="qregexp.html">QRegExp</a> on raw data in memory without requiring to copy the data into a <a href="qstring.html">QString</a>:</p>
<pre>      QRegExp pattern;
      static const QChar unicode[] = {
              0x005A, 0x007F, 0x00A4, 0x0060,
              0x1009, 0x0020, 0x0020};
      int size = sizeof(unicode) / sizeof(QChar);

      QString str = QString::fromRawData(unicode, size);
      if (str.contains(QRegExp(pattern))) {
          <span class="comment">// ...</span>
      }</pre>
<p><b>Warning:</b> A string created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a '\0' character at position <i>size</i>. This means <a href="qstring.html#unicode">unicode</a>() will <i>not</i> return a '\0'-terminated string (although <a href="qstring.html#utf16">utf16</a>() does, at the cost of copying the raw data).</p>
<p>See also <a href="qstring.html#fromUtf16">fromUtf16</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromStdString" />
<h3 class="fn"><a name="fromStdString"></a>QString QString::fromStdString ( const std::string &amp; <i>str</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a copy of the <i>str</i> string. The given string is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>This constructor is only available if Qt is configured with STL compatibility enabled.</p>
<p>See also <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromStdWString" />
<h3 class="fn"><a name="fromStdWString"></a>QString QString::fromStdWString ( const std::wstring &amp; <i>str</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a copy of the <i>str</i> string. The given string is assumed to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g&#x2e; on windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix systems).</p>
<p>This method is only available if Qt is configured with STL compatibility enabled.</p>
<p>See also <a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), and <a href="qstring.html#fromUcs4">fromUcs4</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromUcs4" />
<h3 class="fn"><a name="fromUcs4"></a>QString QString::fromUcs4 ( const <a href="qtglobal.html#uint-typedef">uint</a> * <i>unicode</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UCS-4 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#setUtf16">setUtf16</a>(), and <a href="qstring.html#fromWCharArray">fromWCharArray</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromUtf8" />
<h3 class="fn"><a name="fromUtf8"></a>QString QString::fromUtf8 ( const char * <i>str</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> bytes of the UTF-8 string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).</p>
<p>See also <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), and <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromUtf16" />
<h3 class="fn"><a name="fromUtf16"></a>QString QString::fromUtf16 ( const <a href="qtglobal.html#ushort-typedef">ushort</a> * <i>unicode</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UTF-16 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.</p>
<p><a href="qstring.html">QString</a> makes a deep copy of the Unicode data.</p>
<p>See also <a href="qstring.html#utf16">utf16</a>() and <a href="qstring.html#setUtf16">setUtf16</a>().</p>
<a name="//apple_ref/cpp/clm/QString/fromWCharArray" />
<h3 class="fn"><a name="fromWCharArray"></a>QString QString::fromWCharArray ( const wchar_t * <i>string</i>, int <i>size</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a copy of the <i>string</i>, where the encoding of <i>string</i> depends on the size of wchar. If wchar is 4 bytes, the <i>string</i> is interpreted as ucs-4, if wchar is 2 bytes it is interpreted as ucs-2.</p>
<p>If <i>size</i> is -1 (default), the <i>string</i> has to be 0 terminated.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#fromUcs4">fromUcs4</a>(), and <a href="qstring.html#fromStdWString">fromStdWString</a>().</p>
<a name="//apple_ref/cpp/instm/QString/indexOf" />
<h3 class="fn"><a name="indexOf"></a>int QString::indexOf ( const QString &amp; <i>str</i>, int <i>from</i> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString x = &quot;sticky question&quot;;
     QString y = &quot;sti&quot;;
     x.indexOf(y);               <span class="comment">// returns 0</span>
     x.indexOf(y, 1);            <span class="comment">// returns 10</span>
     x.indexOf(y, 10);           <span class="comment">// returns 10</span>
     x.indexOf(y, 11);           <span class="comment">// returns -1</span></pre>
<p>If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>See also <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#contains">contains</a>(), and <a href="qstring.html#count">count</a>().</p>
<h3 class="fn"><a name="indexOf-2"></a>int QString::indexOf ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i>, int <i>from</i> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString x = &quot;sticky question&quot;;
     QString y = &quot;sti&quot;;
     x.indexOf(y);               <span class="comment">// returns 0</span>
     x.indexOf(y, 1);            <span class="comment">// returns 10</span>
     x.indexOf(y, 10);           <span class="comment">// returns 10</span>
     x.indexOf(y, 11);           <span class="comment">// returns -1</span></pre>
<p>If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>This function was introduced in Qt 4.5.</p>
<p>See also <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#contains">contains</a>(), and <a href="qstring.html#count">count</a>().</p>
<h3 class="fn"><a name="indexOf-3"></a>int QString::indexOf ( <a href="qchar.html">QChar</a> <i>ch</i>, int <i>from</i> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first occurrence of the character <i>ch</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>ch</i> could not be found.</p>
<h3 class="fn"><a name="indexOf-4"></a>int QString::indexOf ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, int <i>from</i> = 0 ) const</h3>
<p>This function overloads <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>Example:</p>
<pre>     QString str = &quot;the minimum&quot;;
     str.indexOf(QRegExp(&quot;m[aeiou]&quot;), 0);       <span class="comment">// returns 4</span></pre>
<h3 class="fn"><a name="indexOf-5"></a>int QString::indexOf ( <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, int <i>from</i> = 0 ) const</h3>
<p>This function overloads <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).</p>
<p>Example:</p>
<pre>     QString str = &quot;the minimum&quot;;
     str.indexOf(QRegExp(&quot;m[aeiou]&quot;), 0);       <span class="comment">// returns 4</span></pre>
<p>This function was introduced in Qt 4.5.</p>
<a name="//apple_ref/cpp/instm/QString/insert" />
<h3 class="fn"><a name="insert"></a>QString &amp; QString::insert ( int <i>position</i>, const QString &amp; <i>str</i> )</h3>
<p>Inserts the string <i>str</i> at the given index <i>position</i> and returns a reference to this string.</p>
<p>Example:</p>
<pre>     QString str = &quot;Meal&quot;;
     str.insert(1, QString(&quot;ontr&quot;));
     <span class="comment">// str == &quot;Montreal&quot;</span></pre>
<p>If the given <i>position</i> is greater than <a href="qstring.html#size">size</a>(), the array is first extended using <a href="qstring.html#resize">resize</a>().</p>
<p>See also <a href="qstring.html#append">append</a>(), <a href="qstring.html#prepend">prepend</a>(), <a href="qstring.html#replace">replace</a>(), and <a href="qstring.html#remove">remove</a>().</p>
<h3 class="fn"><a name="insert-2"></a>QString &amp; QString::insert ( int <i>position</i>, const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the Latin-1 string <i>str</i> at the given index <i>position</i>.</p>
<h3 class="fn"><a name="insert-3"></a>QString &amp; QString::insert ( int <i>position</i>, const <a href="qchar.html">QChar</a> * <i>unicode</i>, int <i>size</i> )</h3>
<p>This function overloads <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i> at the given index <i>position</i> in the string.</p>
<h3 class="fn"><a name="insert-4"></a>QString &amp; QString::insert ( int <i>position</i>, <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts <i>ch</i> at the given index <i>position</i> in the string.</p>
<a name="//apple_ref/cpp/instm/QString/isEmpty" />
<h3 class="fn"><a name="isEmpty"></a>bool QString::isEmpty () const</h3>
<p>Returns true if the string has no characters; otherwise returns false.</p>
<p>Example:</p>
<pre>     QString().isEmpty();            <span class="comment">// returns true</span>
     QString(&quot;&quot;).isEmpty();          <span class="comment">// returns true</span>
     QString(&quot;x&quot;).isEmpty();         <span class="comment">// returns false</span>
     QString(&quot;abc&quot;).isEmpty();       <span class="comment">// returns false</span></pre>
<p>See also <a href="qstring.html#size">size</a>().</p>
<a name="//apple_ref/cpp/instm/QString/isNull" />
<h3 class="fn"><a name="isNull"></a>bool QString::isNull () const</h3>
<p>Returns true if this string is null; otherwise returns false.</p>
<p>Example:</p>
<pre>     QString().isNull();             <span class="comment">// returns true</span>
     QString(&quot;&quot;).isNull();           <span class="comment">// returns false</span>
     QString(&quot;abc&quot;).isNull();        <span class="comment">// returns false</span></pre>
<p>Qt makes a distinction between null strings and empty strings for historical reasons. For most applications, what matters is whether or not a string contains any data, and this can be determined using the <a href="qstring.html#isEmpty">isEmpty</a>() function.</p>
<p>See also <a href="qstring.html#isEmpty">isEmpty</a>().</p>
<a name="//apple_ref/cpp/instm/QString/lastIndexOf" />
<h3 class="fn"><a name="lastIndexOf"></a>int QString::lastIndexOf ( const QString &amp; <i>str</i>, int <i>from</i> = -1, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>. If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString x = &quot;crazy azimuths&quot;;
     QString y = &quot;az&quot;;
     x.lastIndexOf(y);           <span class="comment">// returns 6</span>
     x.lastIndexOf(y, 6);        <span class="comment">// returns 6</span>
     x.lastIndexOf(y, 5);        <span class="comment">// returns 2</span>
     x.lastIndexOf(y, 1);        <span class="comment">// returns -1</span></pre>
<p>See also <a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#contains">contains</a>(), and <a href="qstring.html#count">count</a>().</p>
<h3 class="fn"><a name="lastIndexOf-2"></a>int QString::lastIndexOf ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i>, int <i>from</i> = -1, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>. If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString x = &quot;crazy azimuths&quot;;
     QString y = &quot;az&quot;;
     x.lastIndexOf(y);           <span class="comment">// returns 6</span>
     x.lastIndexOf(y, 6);        <span class="comment">// returns 6</span>
     x.lastIndexOf(y, 5);        <span class="comment">// returns 2</span>
     x.lastIndexOf(y, 1);        <span class="comment">// returns -1</span></pre>
<p>This function was introduced in Qt 4.5.</p>
<p>See also <a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#contains">contains</a>(), and <a href="qstring.html#count">count</a>().</p>
<h3 class="fn"><a name="lastIndexOf-3"></a>int QString::lastIndexOf ( <a href="qchar.html">QChar</a> <i>ch</i>, int <i>from</i> = -1, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last occurrence of the character <i>ch</i>, searching backward from position <i>from</i>.</p>
<h3 class="fn"><a name="lastIndexOf-4"></a>int QString::lastIndexOf ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, int <i>from</i> = -1 ) const</h3>
<p>This function overloads <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>Example:</p>
<pre>     QString str = &quot;the minimum&quot;;
     str.lastIndexOf(QRegExp(&quot;m[aeiou]&quot;));      <span class="comment">// returns 8</span></pre>
<h3 class="fn"><a name="lastIndexOf-5"></a>int QString::lastIndexOf ( <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, int <i>from</i> = -1 ) const</h3>
<p>This function overloads <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).</p>
<p>Example:</p>
<pre>     QString str = &quot;the minimum&quot;;
     str.lastIndexOf(QRegExp(&quot;m[aeiou]&quot;));      <span class="comment">// returns 8</span></pre>
<p>This function was introduced in Qt 4.5.</p>
<a name="//apple_ref/cpp/instm/QString/left" />
<h3 class="fn"><a name="left"></a>QString QString::left ( int <i>n</i> ) const</h3>
<p>Returns a substring that contains the <i>n</i> leftmost characters of the string.</p>
<p>The entire string is returned if <i>n</i> is greater than <a href="qstring.html#size">size</a>() or less than zero.</p>
<pre>     QString x = &quot;Pineapple&quot;;
     QString y = x.left(4);      <span class="comment">// y == &quot;Pine&quot;</span></pre>
<p>See also <a href="qstring.html#right">right</a>(), <a href="qstring.html#mid">mid</a>(), and <a href="qstring.html#startsWith">startsWith</a>().</p>
<a name="//apple_ref/cpp/instm/QString/leftJustified" />
<h3 class="fn"><a name="leftJustified"></a>QString QString::leftJustified ( int <i>width</i>, <a href="qchar.html">QChar</a> <i>fill</i> = QLatin1Char( ' ' ), bool <i>truncate</i> = false ) const</h3>
<p>Returns a string of size <i>width</i> that contains this string padded by the <i>fill</i> character.</p>
<p>If <i>truncate</i> is false and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the returned string is a copy of the string.</p>
<pre>     QString s = &quot;apple&quot;;
     QString t = s.leftJustified(8, '.');    <span class="comment">// t == &quot;apple...&quot;</span></pre>
<p>If <i>truncate</i> is true and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then any characters in a copy of the string after position <i>width</i> are removed, and the copy is returned.</p>
<pre>     QString str = &quot;Pineapple&quot;;
     str = str.leftJustified(5, '.', true);    <span class="comment">// str == &quot;Pinea&quot;</span></pre>
<p>See also <a href="qstring.html#rightJustified">rightJustified</a>().</p>
<a name="//apple_ref/cpp/instm/QString/leftRef" />
<h3 class="fn"><a name="leftRef"></a><a href="qstringref.html">QStringRef</a> QString::leftRef ( int <i>n</i> ) const</h3>
<p>Returns a substring reference to the <i>n</i> leftmost characters of the string.</p>
<p>If <i>n</i> is greater than <a href="qstring.html#size">size</a>() or less than zero, a reference to the entire string is returned.</p>
<pre>     QString x = &quot;Pineapple&quot;;
     QStringRef y = x.leftRef(4);        <span class="comment">// y == &quot;Pine&quot;</span></pre>
<p>This function was introduced in Qt 4.4.</p>
<p>See also <a href="qstring.html#left">left</a>(), <a href="qstring.html#rightRef">rightRef</a>(), <a href="qstring.html#midRef">midRef</a>(), and <a href="qstring.html#startsWith">startsWith</a>().</p>
<a name="//apple_ref/cpp/instm/QString/length" />
<h3 class="fn"><a name="length"></a>int QString::length () const</h3>
<p>Returns the number of characters in this string. Equivalent to <a href="qstring.html#size">size</a>().</p>
<p>See also <a href="qstring-qt3.html#setLength" class="compat">setLength</a>().</p>
<a name="//apple_ref/cpp/clm/QString/localeAwareCompare" />
<h3 class="fn"><a name="localeAwareCompare"></a>int QString::localeAwareCompare ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>On Mac OS X since Qt 4.3, this function compares according the &quot;Order for sorted lists&quot; setting in the International prefereces panel.</p>
<p>See also <a href="qstring.html#compare">compare</a>() and <a href="qtextcodec-qt3.html#locale" class="compat">QTextCodec::locale</a>().</p>
<h3 class="fn"><a name="localeAwareCompare-2"></a>int QString::localeAwareCompare ( const <a href="qstringref.html">QStringRef</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>Same as <tt>localeAwareCompare(*this, other)</tt>.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="localeAwareCompare-3"></a>int QString::localeAwareCompare ( const QString &amp; <i>s1</i>, const <a href="qstringref.html">QStringRef</a> &amp; <i>s2</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This function overloads <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="localeAwareCompare-4"></a>int QString::localeAwareCompare ( const QString &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>Same as <tt>localeAwareCompare(*this, other)</tt>.</p>
<a name="//apple_ref/cpp/instm/QString/mid" />
<h3 class="fn"><a name="mid"></a>QString QString::mid ( int <i>position</i>, int <i>n</i> = -1 ) const</h3>
<p>Returns a string that contains <i>n</i> characters of this string, starting at the specified <i>position</i> index.</p>
<p>Returns a null string if the <i>position</i> index exceeds the length of the string. If there are less than <i>n</i> characters available in the string starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters that are available from the specified <i>position</i>.</p>
<p>Example:</p>
<pre>     QString x = &quot;Nine pineapples&quot;;
     QString y = x.mid(5, 4);            <span class="comment">// y == &quot;pine&quot;</span>
     QString z = x.mid(5);               <span class="comment">// z == &quot;pineapples&quot;</span></pre>
<p>See also <a href="qstring.html#left">left</a>() and <a href="qstring.html#right">right</a>().</p>
<a name="//apple_ref/cpp/instm/QString/midRef" />
<h3 class="fn"><a name="midRef"></a><a href="qstringref.html">QStringRef</a> QString::midRef ( int <i>position</i>, int <i>n</i> = -1 ) const</h3>
<p>Returns a substring reference to <i>n</i> characters of this string, starting at the specified <i>position</i>.</p>
<p>If the <i>position</i> exceeds the length of the string, an empty reference is returned.</p>
<p>If there are less than <i>n</i> characters available in the string, starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters from the specified <i>position</i> onwards.</p>
<p>Example:</p>
<pre>     QString x = &quot;Nine pineapples&quot;;
     QStringRef y = x.midRef(5, 4);      <span class="comment">// y == &quot;pine&quot;</span>
     QStringRef z = x.midRef(5);         <span class="comment">// z == &quot;pineapples&quot;</span></pre>
<p>This function was introduced in Qt 4.4.</p>
<p>See also <a href="qstring.html#mid">mid</a>(), <a href="qstring.html#leftRef">leftRef</a>(), and <a href="qstring.html#rightRef">rightRef</a>().</p>
<a name="//apple_ref/cpp/instm/QString/normalized" />
<h3 class="fn"><a name="normalized"></a>QString QString::normalized ( <a href="qstring.html#NormalizationForm-enum">NormalizationForm</a> <i>mode</i> ) const</h3>
<p>Returns the string in the given Unicode normalization <i>mode</i>.</p>
<h3 class="fn"><a name="normalized-2"></a>QString QString::normalized ( <a href="qstring.html#NormalizationForm-enum">NormalizationForm</a> <i>mode</i>, <a href="qchar.html#UnicodeVersion-enum">QChar::UnicodeVersion</a> <i>version</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the string in the given Unicode normalization <i>mode</i>, according to the given <i>version</i> of the Unicode standard.</p>
<a name="//apple_ref/cpp/clm/QString/number" />
<h3 class="fn"><a name="number"></a>QString QString::number ( long <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a string equivalent of the number <i>n</i> according to the specified <i>base</i>.</p>
<p>The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.</p>
<pre>     long a = 63;
     QString s = QString::number(a, 16);             <span class="comment">// s == &quot;3f&quot;</span>
     QString t = QString::number(a, 16).toUpper();     <span class="comment">// t == &quot;3F&quot;</span></pre>
<p>See also <a href="qstring.html#setNum">setNum</a>().</p>
<h3 class="fn"><a name="number-2"></a>QString QString::number ( double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a string equivalent of the number <i>n</i>, formatted according to the specified <i>format</i> and <i>precision</i>. See <a href="qstring.html#argument-formats">Argument Formats</a> for details.</p>
<p>Unlike <a href="qlocale.html#toString">QLocale::toString</a>(), this function does not honor the user's locale settings.</p>
<p>See also <a href="qstring.html#setNum">setNum</a>() and <a href="qlocale.html#toString">QLocale::toString</a>().</p>
<h3 class="fn"><a name="number-3"></a>QString QString::number ( <a href="qtglobal.html#ulong-typedef">ulong</a> <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="number-4"></a>QString QString::number ( int <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="number-5"></a>QString QString::number ( <a href="qtglobal.html#uint-typedef">uint</a> <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="number-6"></a>QString QString::number ( <a href="qtglobal.html#qlonglong-typedef">qlonglong</a> <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="number-7"></a>QString QString::number ( <a href="qtglobal.html#qulonglong-typedef">qulonglong</a> <i>n</i>, int <i>base</i> = 10 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<a name="//apple_ref/cpp/instm/QString/prepend" />
<h3 class="fn"><a name="prepend"></a>QString &amp; QString::prepend ( const QString &amp; <i>str</i> )</h3>
<p>Prepends the string <i>str</i> to the beginning of this string and returns a reference to this string.</p>
<p>Example:</p>
<pre>     QString x = &quot;ship&quot;;
     QString y = &quot;air&quot;;
     x.prepend(y);
     <span class="comment">// x == &quot;airship&quot;</span></pre>
<p>See also <a href="qstring.html#append">append</a>() and <a href="qstring.html#insert">insert</a>().</p>
<h3 class="fn"><a name="prepend-2"></a>QString &amp; QString::prepend ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends the Latin-1 string <i>str</i> to this string.</p>
<h3 class="fn"><a name="prepend-3"></a>QString &amp; QString::prepend ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This function overloads <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends the byte array <i>ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="prepend-4"></a>QString &amp; QString::prepend ( const char * <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends the string <i>str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="prepend-5"></a>QString &amp; QString::prepend ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends the character <i>ch</i> to this string.</p>
<a name="//apple_ref/cpp/instm/QString/push_back" />
<h3 class="fn"><a name="push_back"></a>void QString::push_back ( const QString &amp; <i>other</i> )</h3>
<p>This function is provided for STL compatibility, appending the given <i>other</i> string onto the end of this string. It is equivalent to <tt>append(other)</tt>.</p>
<p>See also <a href="qstring.html#append">append</a>().</p>
<h3 class="fn"><a name="push_back-2"></a>void QString::push_back ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This is an overloaded function.</p>
<p>Appends the given <i>ch</i> character onto the end of this string.</p>
<a name="//apple_ref/cpp/instm/QString/push_front" />
<h3 class="fn"><a name="push_front"></a>void QString::push_front ( const QString &amp; <i>other</i> )</h3>
<p>This function is provided for STL compatibility, prepending the given <i>other</i> string to the beginning of this string. It is equivalent to <tt>prepend(other)</tt>.</p>
<p>See also <a href="qstring.html#prepend">prepend</a>().</p>
<h3 class="fn"><a name="push_front-2"></a>void QString::push_front ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This is an overloaded function.</p>
<p>Prepends the given <i>ch</i> character to the beginning of this string.</p>
<a name="//apple_ref/cpp/instm/QString/remove" />
<h3 class="fn"><a name="remove"></a>QString &amp; QString::remove ( int <i>position</i>, int <i>n</i> )</h3>
<p>Removes <i>n</i> characters from the string, starting at the given <i>position</i> index, and returns a reference to the string.</p>
<p>If the specified <i>position</i> index is within the string, but <i>position</i> + <i>n</i> is beyond the end of the string, the string is truncated at the specified <i>position</i>.</p>
<pre>     QString s = &quot;Montreal&quot;;
     s.remove(1, 4);
     <span class="comment">// s == &quot;Meal&quot;</span></pre>
<p>See also <a href="qstring.html#insert">insert</a>() and <a href="qstring.html#replace">replace</a>().</p>
<h3 class="fn"><a name="remove-2"></a>QString &amp; QString::remove ( <a href="qchar.html">QChar</a> <i>ch</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>Removes every occurrence of the character <i>ch</i> in this string, and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString t = &quot;Ali Baba&quot;;
     t.remove(QChar('a'), Qt::CaseInsensitive);
     <span class="comment">// t == &quot;li Bb&quot;</span></pre>
<p>This is the same as <tt>replace(ch, &quot;&quot;, cs)</tt>.</p>
<p>See also <a href="qstring.html#replace">replace</a>().</p>
<h3 class="fn"><a name="remove-3"></a>QString &amp; QString::remove ( const QString &amp; <i>str</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>Removes every occurrence of the given <i>str</i> string in this string, and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>This is the same as <tt>replace(str, &quot;&quot;, cs)</tt>.</p>
<p>See also <a href="qstring.html#replace">replace</a>().</p>
<h3 class="fn"><a name="remove-4"></a>QString &amp; QString::remove ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i> )</h3>
<p>Removes every occurrence of the regular expression <i>rx</i> in the string, and returns a reference to the string. For example:</p>
<pre>     QString r = &quot;Telephone&quot;;
     r.remove(QRegExp(&quot;[aeiou].&quot;));
     <span class="comment">// r == &quot;The&quot;</span></pre>
<p>See also <a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), and <a href="qstring.html#replace">replace</a>().</p>
<a name="//apple_ref/cpp/instm/QString/repeated" />
<h3 class="fn"><a name="repeated"></a>QString QString::repeated ( int <i>times</i> ) const</h3>
<p>Returns a copy of this string repeated the specified number of <i>times</i>.</p>
<p>If <i>times</i> is less than 1, an empty string is returned.</p>
<p>Example:</p>
<pre> QString str(&quot;ab&quot;);
 str.repeated(4);            <span class="comment">// returns &quot;abababab&quot;</span></pre>
<p>This function was introduced in Qt 4.5.</p>
<a name="//apple_ref/cpp/instm/QString/replace" />
<h3 class="fn"><a name="replace"></a>QString &amp; QString::replace ( int <i>position</i>, int <i>n</i>, const QString &amp; <i>after</i> )</h3>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>Example:</p>
<pre>     QString x = &quot;Say yes!&quot;;
     QString y = &quot;no&quot;;
     x.replace(4, 3, y);
     <span class="comment">// x == &quot;Say no</span>!&quot;</pre>
<p>See also <a href="qstring.html#insert">insert</a>() and <a href="qstring.html#remove">remove</a>().</p>
<h3 class="fn"><a name="replace-6"></a>QString &amp; QString::replace ( int <i>position</i>, int <i>n</i>, const <a href="qchar.html">QChar</a> * <i>unicode</i>, int <i>size</i> )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i> and returns a reference to this string.</p>
<h3 class="fn"><a name="replace-7"></a>QString &amp; QString::replace ( int <i>position</i>, int <i>n</i>, <a href="qchar.html">QChar</a> <i>after</i> )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the character <i>after</i> and returns a reference to this string.</p>
<h3 class="fn"><a name="replace-8"></a>QString &amp; QString::replace ( const QString &amp; <i>before</i>, const QString &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>Example:</p>
<pre>     QString str = &quot;colour behaviour flavour neighbour&quot;;
     str.replace(QString(&quot;ou&quot;), QString(&quot;o&quot;));
     <span class="comment">// str == &quot;color behavior flavor neighbor&quot;</span></pre>
<p><b>Note:</b> The replacement text is not rescanned after it is inserted.</p>
<p>Example:</p>
<pre>     QString equis = &quot;xxxxxx&quot;;
     equis.replace(&quot;xx&quot;, &quot;x&quot;);
     <span class="comment">// equis == &quot;xxx&quot;</span></pre>
<h3 class="fn"><a name="replace-9"></a>QString &amp; QString::replace ( const <a href="qchar.html">QChar</a> * <i>before</i>, int <i>blen</i>, const <a href="qchar.html">QChar</a> * <i>after</i>, int <i>alen</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces each occurrence in this string of the first <i>blen</i> characters of <i>before</i> with the first <i>alen</i> characters of <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="replace-10"></a>QString &amp; QString::replace ( <a href="qchar.html">QChar</a> <i>ch</i>, const QString &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>ch</i> in the string with <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<h3 class="fn"><a name="replace-11"></a>QString &amp; QString::replace ( <a href="qchar.html">QChar</a> <i>before</i>, <a href="qchar.html">QChar</a> <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>before</i> with the character <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<h3 class="fn"><a name="replace-12"></a>QString &amp; QString::replace ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>before</i>, const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>Note:</b> The text is not rescanned after a replacement.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="replace-13"></a>QString &amp; QString::replace ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>before</i>, const QString &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>Note:</b> The text is not rescanned after a replacement.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="replace-14"></a>QString &amp; QString::replace ( const QString &amp; <i>before</i>, const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>Note:</b> The text is not rescanned after a replacement.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="replace-15"></a>QString &amp; QString::replace ( <a href="qchar.html">QChar</a> <i>c</i>, const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>after</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>c</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>Note:</b> The text is not rescanned after a replacement.</p>
<p>This function was introduced in Qt 4.5.</p>
<h3 class="fn"><a name="replace-16"></a>QString &amp; QString::replace ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, const QString &amp; <i>after</i> )</h3>
<p>This function overloads <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the regular expression <i>rx</i> in the string with <i>after</i>. Returns a reference to the string. For example:</p>
<pre>     QString s = &quot;Banana&quot;;
     s.replace(QRegExp(&quot;a[mn]&quot;), &quot;ox&quot;);
     <span class="comment">// s == &quot;Boxoxa&quot;</span></pre>
<p>For regular expressions containing <a href="qregexp.html#capturing-parentheses">capturing parentheses</a>, occurrences of <b>\1</b>, <b>\2</b>, ..&#x2e;, in <i>after</i> are replaced with <i>rx</i>.cap(1), cap(2), ..&#x2e;</p>
<pre>     QString t = &quot;A &lt;i&gt;bon mot&lt;/i&gt;.&quot;;
     t.replace(QRegExp(&quot;&lt;i&gt;([^&lt;]*)&lt;/i&gt;&quot;), &quot;\\emph{\\1}&quot;);
     <span class="comment">// t == &quot;A \\emph{bon mot}.&quot;</span></pre>
<p>See also <a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#remove">remove</a>(), and <a href="qregexp.html#cap">QRegExp::cap</a>().</p>
<a name="//apple_ref/cpp/instm/QString/reserve" />
<h3 class="fn"><a name="reserve"></a>void QString::reserve ( int <i>size</i> )</h3>
<p>Attempts to allocate memory for at least <i>size</i> characters. If you know in advance how large the string will be, you can call this function, and if you resize the string often you are likely to get better performance. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qstring.html">QString</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the string, call <a href="qstring.html#resize">resize</a>().</p>
<p>This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is true, and we're fairly sure that size is large enough to make a call to reserve() worthwhile:</p>
<pre>     QString result;
     int maxSize;
     bool condition;
     QChar nextChar;

     result.reserve(maxSize);

     while (condition)
         result.append(nextChar);

     result.squeeze();</pre>
<p>See also <a href="qstring.html#squeeze">squeeze</a>() and <a href="qstring.html#capacity">capacity</a>().</p>
<a name="//apple_ref/cpp/instm/QString/resize" />
<h3 class="fn"><a name="resize"></a>void QString::resize ( int <i>size</i> )</h3>
<p>Sets the size of the string to <i>size</i> characters.</p>
<p>If <i>size</i> is greater than the current size, the string is extended to make it <i>size</i> characters long with the extra characters added to the end. The new characters are uninitialized.</p>
<p>If <i>size</i> is less than the current size, characters are removed from the end.</p>
<p>Example:</p>
<pre>     QString s = &quot;Hello world&quot;;
     s.resize(5);
     <span class="comment">// s == &quot;Hello&quot;</span>

     s.resize(8);
     <span class="comment">// s == &quot;Hello???&quot; (where ? stands for any character)</span></pre>
<p>If you want to append a certain number of identical characters to the string, use <a href="qstring.html#operator-2b-eq">operator+=</a>() as follows rather than resize():</p>
<pre>     QString t = &quot;Hello&quot;;
     t += QString(10, 'X');
     <span class="comment">// t == &quot;HelloXXXXXXXXXX&quot;</span></pre>
<p>If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the <a href="qstring.html#leftJustified">leftJustified</a>() function:</p>
<p>If <i>size</i> is negative, it is equivalent to passing zero.</p>
<pre>     QString r = &quot;Hello&quot;;
     r = r.leftJustified(10, ' ');
     <span class="comment">// r == &quot;Hello     &quot;</span></pre>
<p>See also <a href="qstring.html#truncate">truncate</a>() and <a href="qstring.html#reserve">reserve</a>().</p>
<a name="//apple_ref/cpp/instm/QString/right" />
<h3 class="fn"><a name="right"></a>QString QString::right ( int <i>n</i> ) const</h3>
<p>Returns a substring that contains the <i>n</i> rightmost characters of the string.</p>
<p>The entire string is returned if <i>n</i> is greater than <a href="qstring.html#size">size</a>() or less than zero.</p>
<pre>     QString x = &quot;Pineapple&quot;;
     QString y = x.right(5);      <span class="comment">// y == &quot;apple&quot;</span></pre>
<p>See also <a href="qstring.html#left">left</a>(), <a href="qstring.html#mid">mid</a>(), and <a href="qstring.html#endsWith">endsWith</a>().</p>
<a name="//apple_ref/cpp/instm/QString/rightJustified" />
<h3 class="fn"><a name="rightJustified"></a>QString QString::rightJustified ( int <i>width</i>, <a href="qchar.html">QChar</a> <i>fill</i> = QLatin1Char( ' ' ), bool <i>truncate</i> = false ) const</h3>
<p>Returns a string of <a href="qstring.html#size">size</a>() <i>width</i> that contains the <i>fill</i> character followed by the string. For example:</p>
<pre>     QString s = &quot;apple&quot;;
     QString t = s.rightJustified(8, '.');    <span class="comment">// t == &quot;...apple&quot;</span></pre>
<p>If <i>truncate</i> is false and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the returned string is a copy of the string.</p>
<p>If <i>truncate</i> is true and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the resulting string is truncated at position <i>width</i>.</p>
<pre>     QString str = &quot;Pineapple&quot;;
     str = str.rightJustified(5, '.', true);    <span class="comment">// str == &quot;Pinea&quot;</span></pre>
<p>See also <a href="qstring.html#leftJustified">leftJustified</a>().</p>
<a name="//apple_ref/cpp/instm/QString/rightRef" />
<h3 class="fn"><a name="rightRef"></a><a href="qstringref.html">QStringRef</a> QString::rightRef ( int <i>n</i> ) const</h3>
<p>Returns a substring reference to the <i>n</i> rightmost characters of the string.</p>
<p>If <i>n</i> is greater than <a href="qstring.html#size">size</a>() or less than zero, a reference to the entire string is returned.</p>
<pre>     QString x = &quot;Pineapple&quot;;
     QStringRef y = x.rightRef(5);       <span class="comment">// y == &quot;apple&quot;</span></pre>
<p>This function was introduced in Qt 4.4.</p>
<p>See also <a href="qstring.html#right">right</a>(), <a href="qstring.html#leftRef">leftRef</a>(), <a href="qstring.html#midRef">midRef</a>(), and <a href="qstring.html#endsWith">endsWith</a>().</p>
<a name="//apple_ref/cpp/instm/QString/section" />
<h3 class="fn"><a name="section"></a>QString QString::section ( <a href="qchar.html">QChar</a> <i>sep</i>, int <i>start</i>, int <i>end</i> = -1, <a href="qstring.html#SectionFlag-enum">SectionFlags</a> <i>flags</i> = SectionDefault ) const</h3>
<p>This function returns a section of the string.</p>
<p>This string is treated as a sequence of fields separated by the character, <i>sep</i>. The returned string consists of the fields from position <i>start</i> to position <i>end</i> inclusive. If <i>end</i> is not specified, all fields from position <i>start</i> to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.</p>
<p>The <i>flags</i> argument can be used to affect some aspects of the function's behavior, e.g&#x2e; whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see <a href="qstring.html#SectionFlag-enum">SectionFlags</a>.</p>
<pre>     QString str;
     QString csv = &quot;forename,middlename,surname,phone&quot;;
     QString path = &quot;/usr/local/bin/myapp&quot;; <span class="comment">// First field is empty</span>
     QString::SectionFlag flag = QString::SectionSkipEmpty;

     str = csv.section(',', 2, 2);   <span class="comment">// str == &quot;surname&quot;</span>
     str = path.section('/', 3, 4);  <span class="comment">// str == &quot;bin/myapp&quot;</span>
     str = path.section('/', 3, 3, flag); <span class="comment">// str == &quot;myapp&quot;</span></pre>
<p>If <i>start</i> or <i>end</i> is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.</p>
<pre>     str = csv.section(',', -3, -2);  <span class="comment">// str == &quot;middlename,surname&quot;</span>
     str = path.section('/', -1); <span class="comment">// str == &quot;myapp&quot;</span></pre>
<p>See also <a href="qstring.html#split">split</a>().</p>
<h3 class="fn"><a name="section-2"></a>QString QString::section ( const QString &amp; <i>sep</i>, int <i>start</i>, int <i>end</i> = -1, <a href="qstring.html#SectionFlag-enum">SectionFlags</a> <i>flags</i> = SectionDefault ) const</h3>
<p>This function overloads <a href="qstring.html#section">section</a>().</p>
<pre>     QString str;
     QString data = &quot;forename**middlename**surname**phone&quot;;

     str = data.section(&quot;**&quot;, 2, 2); <span class="comment">// str == &quot;surname&quot;</span>
     str = data.section(&quot;**&quot;, -3, -2); <span class="comment">// str == &quot;middlename**surname&quot;</span></pre>
<p>See also <a href="qstring.html#split">split</a>().</p>
<h3 class="fn"><a name="section-3"></a>QString QString::section ( const <a href="qregexp.html">QRegExp</a> &amp; <i>reg</i>, int <i>start</i>, int <i>end</i> = -1, <a href="qstring.html#SectionFlag-enum">SectionFlags</a> <i>flags</i> = SectionDefault ) const</h3>
<p>This function overloads <a href="qstring.html#section">section</a>().</p>
<p>This string is treated as a sequence of fields separated by the regular expression, <i>reg</i>.</p>
<pre>     QString line = &quot;forename\tmiddlename  surname \t \t phone&quot;;
     QRegExp sep(&quot;\\s+&quot;);
     str = line.section(sep, 2, 2); <span class="comment">// s == &quot;surname&quot;</span>
     str = line.section(sep, -3, -2); <span class="comment">// s == &quot;middlename  surname&quot;</span></pre>
<p><b>Warning:</b> Using this <a href="qregexp.html">QRegExp</a> version is much more expensive than the overloaded string and character versions.</p>
<p>See also <a href="qstring.html#split">split</a>() and <a href="qstring.html#simplified">simplified</a>().</p>
<a name="//apple_ref/cpp/instm/QString/setNum" />
<h3 class="fn"><a name="setNum"></a>QString &amp; QString::setNum ( int <i>n</i>, int <i>base</i> = 10 )</h3>
<p>Sets the string to the printed value of <i>n</i> in the specified <i>base</i>, and returns a reference to the string.</p>
<p>The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.</p>
<pre>     QString str;
     str.setNum(1234);       <span class="comment">// str == &quot;1234&quot;</span></pre>
<p>The formatting always uses <a href="qlocale.html#Language-enum">QLocale::C</a>, i.e&#x2e;, English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString">QLocale::toString</a>() with the appropriate locale.</p>
<h3 class="fn"><a name="setNum-2"></a>QString &amp; QString::setNum ( <a href="qtglobal.html#uint-typedef">uint</a> <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-3"></a>QString &amp; QString::setNum ( long <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-4"></a>QString &amp; QString::setNum ( <a href="qtglobal.html#ulong-typedef">ulong</a> <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-5"></a>QString &amp; QString::setNum ( <a href="qtglobal.html#qlonglong-typedef">qlonglong</a> <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-6"></a>QString &amp; QString::setNum ( <a href="qtglobal.html#qulonglong-typedef">qulonglong</a> <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-7"></a>QString &amp; QString::setNum ( short <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-8"></a>QString &amp; QString::setNum ( <a href="qtglobal.html#ushort-typedef">ushort</a> <i>n</i>, int <i>base</i> = 10 )</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="setNum-9"></a>QString &amp; QString::setNum ( double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )</h3>
<p>This is an overloaded function.</p>
<p>Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.</p>
<p>The <i>format</i> can be 'f', 'F', 'e', 'E', 'g' or 'G' (see the <a href="qstring.html#arg">arg</a>() function documentation for an explanation of the formats).</p>
<p>Unlike <a href="qlocale.html#toString">QLocale::toString</a>(), this function doesn't honor the user's locale settings.</p>
<h3 class="fn"><a name="setNum-10"></a>QString &amp; QString::setNum ( float <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6 )</h3>
<p>This is an overloaded function.</p>
<p>Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.</p>
<a name="//apple_ref/cpp/instm/QString/setUnicode" />
<h3 class="fn"><a name="setUnicode"></a>QString &amp; QString::setUnicode ( const <a href="qchar.html">QChar</a> * <i>unicode</i>, int <i>size</i> )</h3>
<p>Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.</p>
<p>If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.</p>
<p>See also <a href="qstring.html#unicode">unicode</a>() and <a href="qstring.html#setUtf16">setUtf16</a>().</p>
<a name="//apple_ref/cpp/instm/QString/setUtf16" />
<h3 class="fn"><a name="setUtf16"></a>QString &amp; QString::setUtf16 ( const <a href="qtglobal.html#ushort-typedef">ushort</a> * <i>unicode</i>, int <i>size</i> )</h3>
<p>Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.</p>
<p>If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.</p>
<p>See also <a href="qstring.html#utf16">utf16</a>() and <a href="qstring.html#setUnicode">setUnicode</a>().</p>
<a name="//apple_ref/cpp/instm/QString/simplified" />
<h3 class="fn"><a name="simplified"></a>QString QString::simplified () const</h3>
<p>Returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre>     QString str = &quot;  lots\t of\nwhitespace\r\n &quot;;
     str = str.simplified();
     <span class="comment">// str == &quot;lots of whitespace&quot;;</span></pre>
<p>See also <a href="qstring.html#trimmed">trimmed</a>().</p>
<a name="//apple_ref/cpp/instm/QString/size" />
<h3 class="fn"><a name="size"></a>int QString::size () const</h3>
<p>Returns the number of characters in this string.</p>
<p>The last character in the string is at position size() - 1. In addition, <a href="qstring.html">QString</a> ensures that the character at position size() is always '\0', so that you can use the return value of <a href="qstring.html#data">data</a>() and <a href="qstring.html#constData">constData</a>() as arguments to functions that expect '\0'-terminated strings.</p>
<p>Example:</p>
<pre>     QString str = &quot;World&quot;;
     int n = str.size();         <span class="comment">// n == 5</span>
     str.data()[0];              <span class="comment">// returns 'W'</span>
     str.data()[4];              <span class="comment">// returns 'd'</span>
     str.data()[5];              <span class="comment">// returns '\0'</span></pre>
<p>See also <a href="qstring.html#isEmpty">isEmpty</a>() and <a href="qstring.html#resize">resize</a>().</p>
<a name="//apple_ref/cpp/instm/QString/split" />
<h3 class="fn"><a name="split"></a><a href="qstringlist.html">QStringList</a> QString::split ( const QString &amp; <i>sep</i>, <a href="qstring.html#SplitBehavior-enum">SplitBehavior</a> <i>behavior</i> = KeepEmptyParts, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Splits the string into substrings wherever <i>sep</i> occurs, and returns the list of those strings. If <i>sep</i> does not match anywhere in the string, split() returns a single-element list containing this string.</p>
<p><i>cs</i> specifies whether <i>sep</i> should be matched case sensitively or case insensitively.</p>
<p>If <i>behavior</i> is <a href="qstring.html#SplitBehavior-enum">QString::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are kept.</p>
<p>Example:</p>
<pre>     QString str = &quot;a,,b,c&quot;;

     QStringList list1 = str.split(&quot;,&quot;);
     <span class="comment">// list1: [ &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot; ]</span>

     QStringList list2 = str.split(&quot;,&quot;, QString::SkipEmptyParts);
     <span class="comment">// list2: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span></pre>
<p>See also <a href="qstringlist.html#join">QStringList::join</a>() and <a href="qstring.html#section">section</a>().</p>
<h3 class="fn"><a name="split-2"></a><a href="qstringlist.html">QStringList</a> QString::split ( const <a href="qchar.html">QChar</a> &amp; <i>sep</i>, <a href="qstring.html#SplitBehavior-enum">SplitBehavior</a> <i>behavior</i> = KeepEmptyParts, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This is an overloaded function.</p>
<h3 class="fn"><a name="split-3"></a><a href="qstringlist.html">QStringList</a> QString::split ( const <a href="qregexp.html">QRegExp</a> &amp; <i>rx</i>, <a href="qstring.html#SplitBehavior-enum">SplitBehavior</a> <i>behavior</i> = KeepEmptyParts ) const</h3>
<p>This is an overloaded function.</p>
<p>Splits the string into substrings wherever the regular expression <i>rx</i> matches, and returns the list of those strings. If <i>rx</i> does not match anywhere in the string, <a href="qstring.html#split">split</a>() returns a single-element list containing this string.</p>
<p>Here's an example where we extract the words in a sentence using one or more whitespace characters as the separator:</p>
<pre>     QString str;
     QStringList list;

     str = &quot;Some  text\n\twith  strange whitespace.&quot;;
     list = str.split(QRegExp(&quot;\\s+&quot;));
     <span class="comment">// list: [ &quot;Some&quot;, &quot;text&quot;, &quot;with&quot;, &quot;strange&quot;, &quot;whitespace.&quot; ]</span></pre>
<p>Here's a similar example, but this time we use any sequence of non-word characters as the separator:</p>
<pre>     str = &quot;This time, a normal English sentence.&quot;;
     list = str.split(QRegExp(&quot;\\W+&quot;), QString::SkipEmptyParts);
     <span class="comment">// list: [ &quot;This&quot;, &quot;time&quot;, &quot;a&quot;, &quot;normal&quot;, &quot;English&quot;, &quot;sentence&quot; ]</span></pre>
<p>Here's a third example where we use a zero-length assertion, <b>\b</b> (word boundary), to split the string into an alternating sequence of non-word and word tokens:</p>
<pre>     str = &quot;Now: this sentence fragment.&quot;;
     list = str.split(QRegExp(&quot;\\b&quot;));
     <span class="comment">// list: [ &quot;&quot;, &quot;Now&quot;, &quot;: &quot;, &quot;this&quot;, &quot; &quot;, &quot;sentence&quot;, &quot; &quot;, &quot;fragment&quot;, &quot;.&quot; ]</span></pre>
<p>See also <a href="qstringlist.html#join">QStringList::join</a>() and <a href="qstring.html#section">section</a>().</p>
<a name="//apple_ref/cpp/instm/QString/sprintf" />
<h3 class="fn"><a name="sprintf"></a>QString &amp; QString::sprintf ( const char * <i>cformat</i>, ... )</h3>
<p>Safely builds a formatted string from the format string <i>cformat</i> and an arbitrary list of arguments.</p>
<p>The %lc escape sequence expects a unicode character of type ushort (as returned by <a href="qchar.html#unicode">QChar::unicode</a>()). The %ls escape sequence expects a pointer to a zero-terminated array of unicode characters of type ushort (as returned by <a href="qstring.html#utf16">QString::utf16</a>()).</p>
<p><b>Note:</b> This function expects a UTF-8 string for %s and Latin-1 for the format string.</p>
<p>The format string supports most of the conversion specifiers provided by printf() in the standard C++ library. It doesn't honor the length modifiers (e.g&#x2e; <tt>h</tt> for <tt>short</tt>, <tt>ll</tt> for <tt>long long</tt>). If you need those, use the standard snprintf() function instead:</p>
<pre>     size_t BufSize;
     char buf[BufSize];

     ::snprintf(buf, BufSize, &quot;%lld&quot;, 123456789LL);
     QString str = QString::fromAscii(buf);</pre>
<p><b>Warning:</b> We do not recommend using QString::sprintf() in new Qt code. Instead, consider using <a href="qtextstream.html">QTextStream</a> or <a href="qstring.html#arg">arg</a>(), both of which support Unicode strings seamlessly and are type-safe. Here's an example that uses <a href="qtextstream.html">QTextStream</a>:</p>
<pre>     QString result;
     QTextStream(&amp;result) &lt;&lt; &quot;pi = &quot; &lt;&lt; 3.14;
     <span class="comment">// result == &quot;pi = 3.14&quot;</span></pre>
<p>For <a href="qobject.html#tr">translations</a>, especially if the strings contains more than one escape sequence, you should consider using the <a href="qstring.html#arg">arg</a>() function instead. This allows the order of the replacements to be controlled by the translator.</p>
<p>See also <a href="qstring.html#arg">arg</a>().</p>
<a name="//apple_ref/cpp/instm/QString/squeeze" />
<h3 class="fn"><a name="squeeze"></a>void QString::squeeze ()</h3>
<p>Releases any memory not required to store the character data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p>See also <a href="qstring.html#reserve">reserve</a>() and <a href="qstring.html#capacity">capacity</a>().</p>
<a name="//apple_ref/cpp/instm/QString/startsWith" />
<h3 class="fn"><a name="startsWith"></a>bool QString::startsWith ( const QString &amp; <i>s</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>Returns true if the string starts with <i>s</i>; otherwise returns false.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<pre>     QString str = &quot;Bananas&quot;;
     str.startsWith(&quot;Ban&quot;);     <span class="comment">// returns true</span>
     str.startsWith(&quot;Car&quot;);     <span class="comment">// returns false</span></pre>
<p>See also <a href="qstring.html#endsWith">endsWith</a>().</p>
<h3 class="fn"><a name="startsWith-3"></a>bool QString::startsWith ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>s</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#startsWith">startsWith</a>().</p>
<h3 class="fn"><a name="startsWith-4"></a>bool QString::startsWith ( const <a href="qchar.html">QChar</a> &amp; <i>c</i>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>cs</i> = Qt::CaseSensitive ) const</h3>
<p>This function overloads <a href="qstring.html#startsWith">startsWith</a>().</p>
<p>Returns true if the string starts with <i>c</i>; otherwise returns false.</p>
<a name="//apple_ref/cpp/instm/QString/toAscii" />
<h3 class="fn"><a name="toAscii"></a><a href="qbytearray.html">QByteArray</a> QString::toAscii () const</h3>
<p>Returns an 8-bit ASCII representation of the string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>If a codec has been set using <a href="qtextcodec.html#setCodecForCStrings">QTextCodec::setCodecForCStrings</a>(), it is used to convert Unicode to 8-bit char; otherwise this function does the same as <a href="qstring.html#toLatin1">toLatin1</a>().</p>
<p>See also <a href="qstring.html#fromAscii">fromAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), and <a href="qtextcodec.html">QTextCodec</a>.</p>
<a name="//apple_ref/cpp/instm/QString/toCaseFolded" />
<h3 class="fn"><a name="toCaseFolded"></a>QString QString::toCaseFolded () const</h3>
<p>Returns the case folded equivalent of the string. For most Unicode characters this is the same as <a href="qstring.html#toLower">toLower</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toDouble" />
<h3 class="fn"><a name="toDouble"></a>double QString::toDouble ( bool * <i>ok</i> = 0 ) const</h3>
<p>Returns the string converted to a <tt>double</tt> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If a conversion error occurs, <tt>*</tt><i>ok</i> is set to false; otherwise <tt>*</tt><i>ok</i> is set to true.</p>
<pre>     QString str = &quot;1234.56&quot;;
     double val = str.toDouble();   <span class="comment">// val == 1234.56</span></pre>
<p>Various string formats for floating point numbers can be converted to double values:</p>
<pre>     bool ok;
     double d;

     d = QString( &quot;1234.56e-02&quot; ).toDouble(&amp;ok); <span class="comment">// ok == true, d == 12.3456</span></pre>
<p>This function tries to interpret the string according to the current locale. The current locale is determined from the system at application startup and can be changed by calling <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). If the string cannot be interpreted according to the current locale, this function falls back on the &quot;C&quot; locale.</p>
<pre>     QLocale::setDefault(QLocale::C);
     d = QString( &quot;1234,56&quot; ).toDouble(&amp;ok); <span class="comment">// ok == false</span>
     d = QString( &quot;1234.56&quot; ).toDouble(&amp;ok); <span class="comment">// ok == true, d == 1234.56</span>

     QLocale::setDefault(QLocale::German);
     d = QString( &quot;1234,56&quot; ).toDouble(&amp;ok); <span class="comment">// ok == true, d == 1234.56</span>
     d = QString( &quot;1234.56&quot; ).toDouble(&amp;ok); <span class="comment">// ok == true, d == 1234.56</span></pre>
<p>Due to the ambiguity between the decimal point and thousands group separator in various locales, this function does not handle thousands group separators. If you need to convert such numbers, see <a href="qlocale.html#toDouble">QLocale::toDouble</a>().</p>
<pre>     QLocale::setDefault(QLocale::C);
     d = QString( &quot;1234,56&quot; ).toDouble(&amp;ok); <span class="comment">// ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qlocale.html#setDefault">QLocale::setDefault</a>(), <a href="qlocale.html#toDouble">QLocale::toDouble</a>(), and <a href="qstring.html#trimmed">trimmed</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toFloat" />
<h3 class="fn"><a name="toFloat"></a>float QString::toFloat ( bool * <i>ok</i> = 0 ) const</h3>
<p>Returns the string converted to a <tt>float</tt> value.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true. Returns 0.0 if the conversion fails.</p>
<p>Example:</p>
<pre>     QString str1 = &quot;1234.56&quot;;
     str1.toFloat();             <span class="comment">// returns 1234.56</span>

     bool ok;
     QString str2 = &quot;R2D2&quot;;
     str2.toFloat(&amp;ok);          <span class="comment">// returns 0.0, sets ok to false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qstring.html#toDouble">toDouble</a>(), and <a href="qstring.html#toInt">toInt</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toInt" />
<h3 class="fn"><a name="toInt"></a>int QString::toInt ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to an <tt>int</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;
     int hex = str.toInt(&amp;ok, 16);       <span class="comment">// hex == 255, ok == true</span>
     int dec = str.toInt(&amp;ok, 10);       <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qstring.html#toUInt">toUInt</a>(), and <a href="qstring.html#toDouble">toDouble</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toLatin1" />
<h3 class="fn"><a name="toLatin1"></a><a href="qbytearray.html">QByteArray</a> QString::toLatin1 () const</h3>
<p>Returns a Latin-1 representation of the string as a <a href="qbytearray.html">QByteArray</a>. The returned byte array is undefined if the string contains non-Latin1 characters.</p>
<p>See also <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), and <a href="qtextcodec.html">QTextCodec</a>.</p>
<a name="//apple_ref/cpp/instm/QString/toLocal8Bit" />
<h3 class="fn"><a name="toLocal8Bit"></a><a href="qbytearray.html">QByteArray</a> QString::toLocal8Bit () const</h3>
<p>Returns the local 8-bit representation of the string as a <a href="qbytearray.html">QByteArray</a>. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.</p>
<p><a href="qtextcodec.html#codecForLocale">QTextCodec::codecForLocale</a>() is used to perform the conversion from Unicode.</p>
<p>See also <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), and <a href="qtextcodec.html">QTextCodec</a>.</p>
<a name="//apple_ref/cpp/instm/QString/toLong" />
<h3 class="fn"><a name="toLong"></a>long QString::toLong ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to a <tt>long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     long hex = str.toLong(&amp;ok, 16);     <span class="comment">// hex == 255, ok == true</span>
     long dec = str.toLong(&amp;ok, 10);     <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qstring.html#toULong">toULong</a>(), and <a href="qstring.html#toInt">toInt</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toLongLong" />
<h3 class="fn"><a name="toLongLong"></a><a href="qtglobal.html#qlonglong-typedef">qlonglong</a> QString::toLongLong ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to a <tt>long long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     qint64 hex = str.toLongLong(&amp;ok, 16);      <span class="comment">// hex == 255, ok == true</span>
     qint64 dec = str.toLongLong(&amp;ok, 10);      <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qstring.html#toULongLong">toULongLong</a>(), and <a href="qstring.html#toInt">toInt</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toLower" />
<h3 class="fn"><a name="toLower"></a>QString QString::toLower () const</h3>
<p>Returns a lowercase copy of the string.</p>
<pre>     QString str = &quot;Qt by NOKIA&quot;;
     str = str.toLower();        <span class="comment">// str == &quot;qy by nokia&quot;</span></pre>
<p>See also <a href="qstring.html#toUpper">toUpper</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toShort" />
<h3 class="fn"><a name="toShort"></a>short QString::toShort ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to a <tt>short</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     short hex = str.toShort(&amp;ok, 16);   <span class="comment">// hex == 255, ok == true</span>
     short dec = str.toShort(&amp;ok, 10);   <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>(), <a href="qstring.html#toUShort">toUShort</a>(), and <a href="qstring.html#toInt">toInt</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toStdString" />
<h3 class="fn"><a name="toStdString"></a>std::string QString::toStdString () const</h3>
<p>Returns a std::string object with the data contained in this <a href="qstring.html">QString</a>. The Unicode data is converted into 8-bit characters using the <a href="qstring.html#toAscii">toAscii</a>() function.</p>
<p>This operator is mostly useful to pass a <a href="qstring.html">QString</a> to a function that accepts a std::string object.</p>
<p>If the <a href="qstring.html">QString</a> contains non-ASCII Unicode characters, using this operator can lead to loss of information, since the implementation calls <a href="qstring.html#toAscii">toAscii</a>().</p>
<p>This operator is only available if Qt is configured with STL compatibility enabled.</p>
<p>See also <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), and <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toStdWString" />
<h3 class="fn"><a name="toStdWString"></a>std::wstring QString::toStdWString () const</h3>
<p>Returns a std::wstring object with the data contained in this <a href="qstring.html">QString</a>. The std::wstring is encoded in utf16 on platforms where wchar_t is 2 bytes wide (e.g&#x2e; windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p>This operator is mostly useful to pass a <a href="qstring.html">QString</a> to a function that accepts a std::wstring object.</p>
<p>This operator is only available if Qt is configured with STL compatibility enabled.</p>
<p>See also <a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), and <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toUInt" />
<h3 class="fn"><a name="toUInt"></a><a href="qtglobal.html#uint-typedef">uint</a> QString::toUInt ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to an <tt>unsigned int</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     uint hex = str.toUInt(&amp;ok, 16);     <span class="comment">// hex == 255, ok == true</span>
     uint dec = str.toUInt(&amp;ok, 10);     <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>() and <a href="qstring.html#toInt">toInt</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toULong" />
<h3 class="fn"><a name="toULong"></a><a href="qtglobal.html#ulong-typedef">ulong</a> QString::toULong ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to an <tt>unsigned long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     ulong hex = str.toULong(&amp;ok, 16);   <span class="comment">// hex == 255, ok == true</span>
     ulong dec = str.toULong(&amp;ok, 10);   <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toULongLong" />
<h3 class="fn"><a name="toULongLong"></a><a href="qtglobal.html#qulonglong-typedef">qulonglong</a> QString::toULongLong ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to an <tt>unsigned long long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     quint64 hex = str.toULongLong(&amp;ok, 16);    <span class="comment">// hex == 255, ok == true</span>
     quint64 dec = str.toULongLong(&amp;ok, 10);    <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>() and <a href="qstring.html#toLongLong">toLongLong</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toUShort" />
<h3 class="fn"><a name="toUShort"></a><a href="qtglobal.html#ushort-typedef">ushort</a> QString::toUShort ( bool * <i>ok</i> = 0, int <i>base</i> = 10 ) const</h3>
<p>Returns the string converted to an <tt>unsigned short</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>Example:</p>
<pre>     QString str = &quot;FF&quot;;
     bool ok;

     ushort hex = str.toUShort(&amp;ok, 16);     <span class="comment">// hex == 255, ok == true</span>
     ushort dec = str.toUShort(&amp;ok, 10);     <span class="comment">// dec == 0, ok == false</span></pre>
<p>See also <a href="qstring.html#number">number</a>() and <a href="qstring.html#toShort">toShort</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toUcs4" />
<h3 class="fn"><a name="toUcs4"></a><a href="qvector.html">QVector</a>&lt;<a href="qtglobal.html#uint-typedef">uint</a>&gt; QString::toUcs4 () const</h3>
<p>Returns a UCS-4 representation of the string as a <a href="qvector.html">QVector</a>&lt;uint&gt;.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), <a href="qtextcodec.html">QTextCodec</a>, <a href="qstring.html#fromUcs4">fromUcs4</a>(), and <a href="qstring.html#toWCharArray">toWCharArray</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toUpper" />
<h3 class="fn"><a name="toUpper"></a>QString QString::toUpper () const</h3>
<p>Returns an uppercase copy of the string.</p>
<pre>     QString str = &quot;TeXt&quot;;
     str = str.toUpper();        <span class="comment">// str == &quot;TEXT&quot;</span></pre>
<p>See also <a href="qstring.html#toLower">toLower</a>().</p>
<a name="//apple_ref/cpp/instm/QString/toUtf8" />
<h3 class="fn"><a name="toUtf8"></a><a href="qbytearray.html">QByteArray</a> QString::toUtf8 () const</h3>
<p>Returns a UTF-8 representation of the string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>See also <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), and <a href="qtextcodec.html">QTextCodec</a>.</p>
<a name="//apple_ref/cpp/instm/QString/toWCharArray" />
<h3 class="fn"><a name="toWCharArray"></a>int QString::toWCharArray ( wchar_t * <i>array</i> ) const</h3>
<p>Fills the <i>array</i> with the data contained in this <a href="qstring.html">QString</a> object. The array is encoded in utf16 on platforms where wchar_t is 2 bytes wide (e.g&#x2e; windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p><i>array</i> has to be allocated by the caller and contain enough space to hold the complete string (allocating the array with the same length as the string is always sufficient).</p>
<p>returns the actual length of the string in <i>array</i>.</p>
<p><b>Note:</b> This function does not append a null character to the array.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#toAscii">toAscii</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), and <a href="qstring.html#toStdWString">toStdWString</a>().</p>
<a name="//apple_ref/cpp/instm/QString/trimmed" />
<h3 class="fn"><a name="trimmed"></a>QString QString::trimmed () const</h3>
<p>Returns a string that has whitespace removed from the start and the end.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre>     QString str = &quot;  lots\t of\nwhitespace\r\n &quot;;
     str = str.trimmed();
     <span class="comment">// str == &quot;lots\t of\nwhitespace&quot;</span></pre>
<p>Unlike <a href="qstring.html#simplified">simplified</a>(), trimmed() leaves internal whitespace alone.</p>
<p>See also <a href="qstring.html#simplified">simplified</a>().</p>
<a name="//apple_ref/cpp/instm/QString/truncate" />
<h3 class="fn"><a name="truncate"></a>void QString::truncate ( int <i>position</i> )</h3>
<p>Truncates the string at the given <i>position</i> index.</p>
<p>If the specified <i>position</i> index is beyond the end of the string, nothing happens.</p>
<p>Example:</p>
<pre>     QString str = &quot;Vladivostok&quot;;
     str.truncate(4);
     <span class="comment">// str == &quot;Vlad&quot;</span></pre>
<p>If <i>position</i> is negative, it is equivalent to passing zero.</p>
<p>See also <a href="qstring.html#chop">chop</a>(), <a href="qstring.html#resize">resize</a>(), and <a href="qstring.html#left">left</a>().</p>
<a name="//apple_ref/cpp/instm/QString/unicode" />
<h3 class="fn"><a name="unicode"></a>const <a href="qchar.html">QChar</a> * QString::unicode () const</h3>
<p>Returns a '\0'-terminated Unicode representation of the string. The result remains valid until the string is modified.</p>
<p>See also <a href="qstring.html#setUnicode">setUnicode</a>() and <a href="qstring.html#utf16">utf16</a>().</p>
<a name="//apple_ref/cpp/instm/QString/utf16" />
<h3 class="fn"><a name="utf16"></a>const <a href="qtglobal.html#ushort-typedef">ushort</a> * QString::utf16 () const</h3>
<p>Returns the <a href="qstring.html">QString</a> as a '\0'-terminated array of unsigned shorts. The result remains valid until the string is modified.</p>
<p>See also <a href="qstring.html#setUtf16">setUtf16</a>() and <a href="qstring.html#unicode">unicode</a>().</p>
<a name="//apple_ref/cpp/instm/QString/vsprintf" />
<h3 class="fn"><a name="vsprintf"></a>QString &amp; QString::vsprintf ( const char * <i>cformat</i>, va_list <i>ap</i> )</h3>
<p>Equivalent method to <a href="qstring.html#sprintf">sprintf</a>(), but takes a va_list <i>ap</i> instead a list of variable arguments. See the <a href="qstring.html#sprintf">sprintf</a>() documentation for an explanation of <i>cformat</i>.</p>
<p>This method does not call the va_end macro, the caller is responsible to call va_end on <i>ap</i>.</p>
<p>See also <a href="qstring.html#sprintf">sprintf</a>().</p>
<a name="//apple_ref/cpp/instm/QString/operator!=" />
<h3 class="fn"><a name="operator-not-eq"></a>bool QString::operator!= ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if this string is not equal to string <i>other</i>; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<h3 class="fn"><a name="operator-not-eq-2"></a>bool QString::operator!= ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-not-eq">operator!=</a>().</p>
<h3 class="fn"><a name="operator-not-eq-3"></a>bool QString::operator!= ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-not-eq">operator!=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-not-eq-4"></a>bool QString::operator!= ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-not-eq">operator!=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator+=" />
<h3 class="fn"><a name="operator-2b-eq"></a>QString &amp; QString::operator+= ( const QString &amp; <i>other</i> )</h3>
<p>Appends the string <i>other</i> onto the end of this string and returns a reference to this string.</p>
<p>Example:</p>
<pre>     QString x = &quot;free&quot;;
     QString y = &quot;dom&quot;;
     x += y;
     <span class="comment">// x == &quot;freedom&quot;</span></pre>
<p>This operation is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qstring.html">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p>See also <a href="qstring.html#append">append</a>() and <a href="qstring.html#prepend">prepend</a>().</p>
<h3 class="fn"><a name="operator-2b-eq-2"></a>QString &amp; QString::operator+= ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the Latin-1 string <i>str</i> to this string.</p>
<h3 class="fn"><a name="operator-2b-eq-3"></a>QString &amp; QString::operator+= ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the byte array <i>ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-2b-eq-4"></a>QString &amp; QString::operator+= ( const char * <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the string <i>str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-2b-eq-5"></a>QString &amp; QString::operator+= ( const <a href="qstringref.html">QStringRef</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the string section referenced by <i>str</i> to this string.</p>
<h3 class="fn"><a name="operator-2b-eq-6"></a>QString &amp; QString::operator+= ( char <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the character <i>ch</i> to this string. The character is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-2b-eq-7"></a>QString &amp; QString::operator+= ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the character <i>ch</i> to the string.</p>
<a name="//apple_ref/cpp/instm/QString/operator&lt;" />
<h3 class="fn"><a name="operator-lt"></a>bool QString::operator&lt; ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if this string is lexically less than string <i>other</i>; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<h3 class="fn"><a name="operator-lt-2"></a>bool QString::operator&lt; ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt">operator&lt;</a>().</p>
<h3 class="fn"><a name="operator-lt-3"></a>bool QString::operator&lt; ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt">operator&lt;</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-lt-4"></a>bool QString::operator&lt; ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt">operator&lt;</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator&lt;=" />
<h3 class="fn"><a name="operator-lt-eq"></a>bool QString::operator&lt;= ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if this string is lexically less than or equal to string <i>other</i>; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<h3 class="fn"><a name="operator-lt-eq-2"></a>bool QString::operator&lt;= ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt-eq">operator&lt;=</a>().</p>
<h3 class="fn"><a name="operator-lt-eq-3"></a>bool QString::operator&lt;= ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt-eq">operator&lt;=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-lt-eq-4"></a>bool QString::operator&lt;= ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-lt-eq">operator&lt;=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator=" />
<h3 class="fn"><a name="operator-eq"></a>QString &amp; QString::operator= ( const QString &amp; <i>other</i> )</h3>
<p>Assigns <i>other</i> to this string and returns a reference to this string.</p>
<h3 class="fn"><a name="operator-eq-3"></a>QString &amp; QString::operator= ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns the Latin-1 string <i>str</i> to this string.</p>
<h3 class="fn"><a name="operator-eq-4"></a>QString &amp; QString::operator= ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns <i>ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-eq-5"></a>QString &amp; QString::operator= ( const char * <i>str</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns <i>str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-eq-6"></a>QString &amp; QString::operator= ( char <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns character <i>ch</i> to this string. The character is converted to Unicode using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-eq-7"></a>QString &amp; QString::operator= ( <a href="qchar.html">QChar</a> <i>ch</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Sets the string to contain the single character <i>ch</i>.</p>
<a name="//apple_ref/cpp/instm/QString/operator==" />
<h3 class="fn"><a name="operator-eq-eq"></a>bool QString::operator== ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if string <i>other</i> is equal to this string; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<h3 class="fn"><a name="operator-eq-eq-2"></a>bool QString::operator== ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-eq-eq">operator==</a>().</p>
<h3 class="fn"><a name="operator-eq-eq-3"></a>bool QString::operator== ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-eq-eq">operator==</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-eq-eq-4"></a>bool QString::operator== ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-eq-eq">operator==</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator&gt;" />
<h3 class="fn"><a name="operator-gt"></a>bool QString::operator&gt; ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if this string is lexically greater than string <i>other</i>; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<h3 class="fn"><a name="operator-gt-2"></a>bool QString::operator&gt; ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<h3 class="fn"><a name="operator-gt-3"></a>bool QString::operator&gt; ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-gt-4"></a>bool QString::operator&gt; ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator&gt;=" />
<h3 class="fn"><a name="operator-gt-eq"></a>bool QString::operator&gt;= ( const QString &amp; <i>other</i> ) const</h3>
<p>Returns true if this string is lexically greater than or equal to string <i>other</i>; otherwise returns false.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<h3 class="fn"><a name="operator-gt-eq-2"></a>bool QString::operator&gt;= ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt-eq">operator&gt;=</a>().</p>
<h3 class="fn"><a name="operator-gt-eq-3"></a>bool QString::operator&gt;= ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt-eq">operator&gt;=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<h3 class="fn"><a name="operator-gt-eq-4"></a>bool QString::operator&gt;= ( const char * <i>other</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-gt-eq">operator&gt;=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromAscii">fromAscii</a>() function.</p>
<p>You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<a name="//apple_ref/cpp/instm/QString/operator[]" />
<h3 class="fn"><a name="operator-5b-5d"></a>QCharRef QString::operator[] ( int <i>position</i> )</h3>
<p>Returns the character at the specified <i>position</i> in the string as a modifiable reference.</p>
<p>Example:</p>
<pre>     QString str;

     if (str[0] == QChar('?'))
         str[0] = QChar('_');</pre>
<p>The return value is of type QCharRef, a helper class for <a href="qstring.html">QString</a>. When you get an object of type QCharRef, you can use it as if it were a <a href="qchar.html">QChar</a> &amp;. If you assign to it, the assignment will apply to the character in the <a href="qstring.html">QString</a> from which you got the reference.</p>
<p>See also <a href="qstring.html#at">at</a>().</p>
<h3 class="fn"><a name="operator-5b-5d-2"></a>const <a href="qchar.html">QChar</a> QString::operator[] ( int <i>position</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<h3 class="fn"><a name="operator-5b-5d-3"></a>QCharRef QString::operator[] ( <a href="qtglobal.html#uint-typedef">uint</a> <i>position</i> )</h3>
<p>This function overloads <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<p>Returns the character at the specified <i>position</i> in the string as a modifiable reference. Equivalent to <tt>at(position)</tt>.</p>
<h3 class="fn"><a name="operator-5b-5d-4"></a>const <a href="qchar.html">QChar</a> QString::operator[] ( <a href="qtglobal.html#uint-typedef">uint</a> <i>position</i> ) const</h3>
<p>This function overloads <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="operator-not-eq-15"></a>bool operator!= ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns true if <i>s1</i> is not equal to <i>s2</i>; otherwise returns false.</p>
<p>For <i>s1</i> != 0, this is equivalent to <tt>compare(</tt> <i>s1</i>, <i>s2</i> <tt>) != 0</tt>. Note that no string is equal to <i>s1</i> being 0.</p>
<p>See also <a href="qstring.html#compare">QString::compare</a>().</p>
<h3 class="fn"><a name="operator-2b-10"></a>const QString operator+ ( const QString &amp; <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i>.</p>
<h3 class="fn"><a name="operator-2b-13"></a>const QString operator+ ( const QString &amp; <i>s1</i>, const char * <i>s2</i> )</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i> (<i>s2</i> is converted to Unicode using the <a href="qstring.html#fromAscii">QString::fromAscii</a>() function).</p>
<p>See also <a href="qstring.html#fromAscii">QString::fromAscii</a>().</p>
<h3 class="fn"><a name="operator-2b-14"></a>const QString operator+ ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i> (<i>s1</i> is converted to Unicode using the <a href="qstring.html#fromAscii">QString::fromAscii</a>() function).</p>
<p>See also <a href="qstring.html#fromAscii">QString::fromAscii</a>().</p>
<h3 class="fn"><a name="operator-2b-15"></a>const QString operator+ ( char <i>ch</i>, const QString &amp; <i>s</i> )</h3>
<p>Returns a string which is the result of concatenating the character <i>ch</i> and the string <i>s</i>.</p>
<h3 class="fn"><a name="operator-2b-16"></a>const QString operator+ ( const QString &amp; <i>s</i>, char <i>ch</i> )</h3>
<p>Returns a string which is the result of concatenating the string <i>s</i> and the character <i>ch</i>.</p>
<h3 class="fn"><a name="operator-lt-5"></a>bool operator&lt; ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns true if <i>s1</i> is lexically less than <i>s2</i>; otherwise returns false. For <i>s1</i> != 0, this is equivalent to <tt>compare(s1, s2) &lt; 0</tt>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<p>See also <a href="qstring.html#compare">QString::compare</a>().</p>
<h3 class="fn"><a name="operator-lt-lt-42"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>stream</i>, const QString &amp; <i>string</i> )</h3>
<p>Writes the given <i>string</i> to the specified <i>stream</i>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream Operators</a>.</p>
<h3 class="fn"><a name="operator-lt-eq-5"></a>bool operator&lt;= ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns true if <i>s1</i> is lexically less than or equal to <i>s2</i>; otherwise returns false. For <i>s1</i> != 0, this is equivalent to <tt>compare(s1, s2) &lt;= 0</tt>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>().</p>
<p>See also <a href="qstring.html#compare">QString::compare</a>().</p>
<h3 class="fn"><a name="operator-eq-eq-85"></a>bool operator== ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>This function overloads <a href="qchar.html#operator-eq-eq">operator==</a>().</p>
<p>Returns true if <i>s1</i> is equal to <i>s2</i>; otherwise returns false. Note that no string is equal to <i>s1</i> being 0.</p>
<p>Equivalent to <tt>s1 != 0 &amp;&amp; compare(s1, s2) == 0</tt>.</p>
<p>See also <a href="qstring.html#compare">QString::compare</a>().</p>
<h3 class="fn"><a name="operator-gt-5"></a>bool operator&gt; ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns true if <i>s1</i> is lexically greater than <i>s2</i>; otherwise returns false. Equivalent to <tt>compare(s1, s2) &gt; 0</tt>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<p>See also <a href="qstring.html#compare">QString::compare</a>().</p>
<h3 class="fn"><a name="operator-gt-eq-5"></a>bool operator&gt;= ( const char * <i>s1</i>, const QString &amp; <i>s2</i> )</h3>
<p>Returns true if <i>s1</i> is lexically greater than or equal to <i>s2</i>; otherwise returns false. For <i>s1</i> != 0, this is equivalent to <tt>compare(s1, s2) &gt;= 0</tt>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<h3 class="fn"><a name="operator-gt-gt-22"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>stream</i>, QString &amp; <i>string</i> )</h3>
<p>Reads a string from the specified <i>stream</i> into the given <i>string</i>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream Operators</a>.</p>
<hr />
<h2>Macro Documentation</h2>
<a name="//apple_ref/cpp/macro//QT_NO_CAST_FROM_ASCII" />
<h3 class="fn"><a name="QT_NO_CAST_FROM_ASCII"></a>QT_NO_CAST_FROM_ASCII</h3>
<p>Disables automatic conversions from 8-bit strings (char *) to unicode QStrings</p>
<p>See also <a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a> and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<a name="//apple_ref/cpp/macro//QT_NO_CAST_TO_ASCII" />
<h3 class="fn"><a name="QT_NO_CAST_TO_ASCII"></a>QT_NO_CAST_TO_ASCII</h3>
<p>disables automatic conversion from <a href="qstring.html">QString</a> to ASCII 8-bit strings (char *)</p>
<p>See also <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="40%" align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="40%" align="right"><div align="right">Qt 4.6.0</div></td>
</tr></table></div></address></body>
</html>
