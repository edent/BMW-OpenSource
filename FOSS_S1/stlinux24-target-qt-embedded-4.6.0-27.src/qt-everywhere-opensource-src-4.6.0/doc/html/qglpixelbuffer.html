<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- qglpixelbuffer.cpp -->
<head>
  <title>Qt 4.6: QGLPixelBuffer Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a name="//apple_ref/cpp/cl//QGLPixelBuffer" />
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot; <a href="overviews.html"><font color="#004faf">Overviews</font></a></td></tr></table><h1 class="title">QGLPixelBuffer Class Reference<br /><span class="small-subtitle">[<a href="qtopengl.html">QtOpenGL</a> module]</span>
</h1>
<p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer. <a href="#details">More...</a></p>
<pre> #include &lt;QGLPixelBuffer&gt;</pre><p><b>This class is not part of the Qt GUI Framework Edition.</b></p>
<p>Inherits <a href="qpaintdevice.html">QPaintDevice</a>.</p>
<p>This class was introduced in Qt 4.1.</p>
<ul>
<li><a href="qglpixelbuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<hr />
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#QGLPixelBuffer">QGLPixelBuffer</a></b> ( const QSize &amp; <i>size</i>, const QGLFormat &amp; <i>format</i> = QGLFormat::defaultFormat(), QGLWidget * <i>shareWidget</i> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#QGLPixelBuffer-2">QGLPixelBuffer</a></b> ( int <i>width</i>, int <i>height</i>, const QGLFormat &amp; <i>format</i> = QGLFormat::defaultFormat(), QGLWidget * <i>shareWidget</i> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#dtor.QGLPixelBuffer">~QGLPixelBuffer</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#bindTexture">bindTexture</a></b> ( const QImage &amp; <i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#bindTexture-2">bindTexture</a></b> ( const QPixmap &amp; <i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#bindTexture-3">bindTexture</a></b> ( const QString &amp; <i>fileName</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a></b> ( GLuint <i>texture_id</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a></b> ( GLuint <i>texture_id</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#doneCurrent">doneCurrent</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#drawTexture">drawTexture</a></b> ( const QRectF &amp; <i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#drawTexture-2">drawTexture</a></b> ( const QPointF &amp; <i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QGLFormat </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#format">format</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Qt::HANDLE </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#handle">handle</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#isValid">isValid</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#makeCurrent">makeCurrent</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QSize </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QImage </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#toImage">toImage</a></b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a></b> ( GLuint <i>texture_id</i> ) const</td></tr>
</table>
<hr />
<a name="reimplemented-public-functions"></a>
<h2>Reimplemented Public Functions</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">virtual QPaintEngine * </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#paintEngine">paintEngine</a></b> () const</td></tr>
</table>
<ul>
<li><div bar="2" class="fn"></div>12 public functions inherited from <a href="qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<hr />
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#hasOpenGLPbuffers">hasOpenGLPbuffers</a></b> ()</td></tr>
</table>
<hr />
<a name="reimplemented-protected-functions"></a>
<h2>Reimplemented Protected Functions</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><b><a href="qglpixelbuffer.html#metric">metric</a></b> ( PaintDeviceMetric <i>metric</i> ) const</td></tr>
</table>
<ul>
<li><div bar="2" class="fn"></div>1 protected function inherited from <a href="qpaintdevice.html#protected-functions">QPaintDevice</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer.</p>
<p>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a <a href="qpixmap.html">QPixmap</a>.</p>
<p>There are three approaches to using this class:</p>
<ol type="1">
<li><b>We can draw into the pbuffer and convert it to a <a href="qimage.html">QImage</a> using <a href="qglpixelbuffer.html#toImage">toImage</a>().</b> This is normally much faster than calling <a href="qglwidget.html#renderPixmap">QGLWidget::renderPixmap</a>().</li>
<li><b>We can draw into the pbuffer and copy the contents into an OpenGL texture using <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</b> This allows us to create dynamic textures and works on all systems with pbuffer support.</li>
<li><b>On systems that support it, we can bind the pbuffer to an OpenGL texture.</b> The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and Mac OS X systems that provide the <tt>render_texture</tt> extension.</li>
</ol>
<p>Pbuffers are provided by the OpenGL <tt>pbuffer</tt> extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</p>
<p>See also <a href="opengl-pbuffers.html">Pbuffers Example</a>.</p>
<hr />
<h2>Member Function Documentation</h2>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/QGLPixelBuffer" />
<h3 class="fn"><a name="QGLPixelBuffer"></a>QGLPixelBuffer::QGLPixelBuffer ( const <a href="qsize.html">QSize</a> &amp; <i>size</i>, const <a href="qglformat.html">QGLFormat</a> &amp; <i>format</i> = QGLFormat::defaultFormat(), <a href="qglwidget.html">QGLWidget</a> * <i>shareWidget</i> = 0 )</h3>
<p>Constructs an OpenGL pbuffer of the given <i>size</i>. If no <i>format</i> is specified, the <a href="qglformat.html#defaultFormat">default format</a> is used. If the <i>shareWidget</i> parameter points to a valid <a href="qglwidget.html">QGLWidget</a>, the pbuffer will share its context with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <tt>size</tt> must be powers of two (e.g&#x2e;, 512 x 128).</p>
<p>See also <a href="qglpixelbuffer.html#size">size</a>() and <a href="qglpixelbuffer.html#format">format</a>().</p>
<h3 class="fn"><a name="QGLPixelBuffer-2"></a>QGLPixelBuffer::QGLPixelBuffer ( int <i>width</i>, int <i>height</i>, const <a href="qglformat.html">QGLFormat</a> &amp; <i>format</i> = QGLFormat::defaultFormat(), <a href="qglwidget.html">QGLWidget</a> * <i>shareWidget</i> = 0 )</h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL pbuffer with the <i>width</i> and <i>height</i>. If no <i>format</i> is specified, the <a href="qglformat.html#defaultFormat">default format</a> is used. If the <i>shareWidget</i> parameter points to a valid <a href="qglwidget.html">QGLWidget</a>, the pbuffer will share its context with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <tt>size</tt> must be powers of two (e.g&#x2e;, 512 x 128).</p>
<p>See also <a href="qglpixelbuffer.html#size">size</a>() and <a href="qglpixelbuffer.html#format">format</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/~QGLPixelBuffer" />
<h3 class="fn"><a name="dtor.QGLPixelBuffer"></a>QGLPixelBuffer::~QGLPixelBuffer ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Destroys the pbuffer and frees any allocated resources.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/bindTexture" />
<h3 class="fn"><a name="bindTexture"></a>GLuint QGLPixelBuffer::bindTexture ( const <a href="qimage.html">QImage</a> &amp; <i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D )</h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later glBindTexture() calls.</p>
<p>The <i>target</i> parameter specifies the texture target.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext::bindTexture</a>().</p>
<p>See also <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>
<h3 class="fn"><a name="bindTexture-2"></a>GLuint QGLPixelBuffer::bindTexture ( const <a href="qpixmap.html">QPixmap</a> &amp; <i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D )</h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext::bindTexture</a>().</p>
<p>See also <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>
<h3 class="fn"><a name="bindTexture-3"></a>GLuint QGLPixelBuffer::bindTexture ( const <a href="qstring.html">QString</a> &amp; <i>fileName</i> )</h3>
<p>This is an overloaded function.</p>
<p>Reads the DirectDrawSurface (DDS) compressed file <i>fileName</i> and generates a 2D GL texture from it.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext::bindTexture</a>().</p>
<p>See also <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/bindToDynamicTexture" />
<h3 class="fn"><a name="bindToDynamicTexture"></a>bool QGLPixelBuffer::bindToDynamicTexture ( GLuint <i>texture_id</i> )</h3>
<p>Binds the texture specified by <i>texture_id</i> to this pbuffer. Returns true on success; otherwise returns false.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>To unbind the texture, call <a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a>(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</p>
<p>Example:</p>
<pre> QGLPixelBuffer pbuffer(...);
 ...
 pbuffer.makeCurrent();
 GLuint dynamicTexture = pbuffer.generateDynamicTexture();
 pbuffer.bindToDynamicTexture(dynamicTexture);
 ...
 pbuffer.releaseFromDynamicTexture();</pre>
<p><b>Warning:</b> This function uses the <tt>render_texture</tt> extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</p>
<p><b>Warning:</b> For the bindToDynamicTexture() call to succeed on the Mac OS X, the pbuffer needs a shared context, i.e&#x2e; the <a href="qglpixelbuffer.html">QGLPixelBuffer</a> must be created with a share widget.</p>
<p>See also <a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>() and <a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/deleteTexture" />
<h3 class="fn"><a name="deleteTexture"></a>void QGLPixelBuffer::deleteTexture ( GLuint <i>texture_id</i> )</h3>
<p>Removes the texture identified by <i>texture_id</i> from the texture cache.</p>
<p>Equivalent to calling <a href="qglcontext.html#deleteTexture">QGLContext::deleteTexture</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/doneCurrent" />
<h3 class="fn"><a name="doneCurrent"></a>bool QGLPixelBuffer::doneCurrent ()</h3>
<p>Makes no context the current OpenGL context. Returns true on success; otherwise returns false.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/drawTexture" />
<h3 class="fn"><a name="drawTexture"></a>void QGLPixelBuffer::drawTexture ( const <a href="qrectf.html">QRectF</a> &amp; <i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</h3>
<p>Draws the given texture, <i>textureId</i>, to the given target rectangle, <i>target</i>, in OpenGL model space. The <i>textureTarget</i> should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<h3 class="fn"><a name="drawTexture-2"></a>void QGLPixelBuffer::drawTexture ( const <a href="qpointf.html">QPointF</a> &amp; <i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</h3>
<p>Draws the given texture, <i>textureId</i>, at the given <i>point</i> in OpenGL model space. The textureTarget parameter should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/format" />
<h3 class="fn"><a name="format"></a><a href="qglformat.html">QGLFormat</a> QGLPixelBuffer::format () const</h3>
<p>Returns the format of the pbuffer. The format may be different from the one that was requested.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/generateDynamicTexture" />
<h3 class="fn"><a name="generateDynamicTexture"></a>GLuint QGLPixelBuffer::generateDynamicTexture () const</h3>
<p>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>() and <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</p>
<p>See also <a href="qglpixelbuffer.html#size">size</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/handle" />
<h3 class="fn"><a name="handle"></a><a href="qt.html#HANDLE-typedef">Qt::HANDLE</a> QGLPixelBuffer::handle () const</h3>
<p>Returns the native pbuffer handle.</p>
<a name="//apple_ref/cpp/clm/QGLPixelBuffer/hasOpenGLPbuffers" />
<h3 class="fn"><a name="hasOpenGLPbuffers"></a>bool QGLPixelBuffer::hasOpenGLPbuffers ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns true if the OpenGL <tt>pbuffer</tt> extension is present on this system; otherwise returns false.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/isValid" />
<h3 class="fn"><a name="isValid"></a>bool QGLPixelBuffer::isValid () const</h3>
<p>Returns true if this pbuffer is valid; otherwise returns false.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/makeCurrent" />
<h3 class="fn"><a name="makeCurrent"></a>bool QGLPixelBuffer::makeCurrent ()</h3>
<p>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns false.</p>
<p>See also <a href="qglcontext.html#makeCurrent">QGLContext::makeCurrent</a>() and <a href="qglpixelbuffer.html#doneCurrent">doneCurrent</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/metric" />
<h3 class="fn"><a name="metric"></a>int QGLPixelBuffer::metric ( <a href="qpaintdevice.html#PaintDeviceMetric-enum">PaintDeviceMetric</a> <i>metric</i> ) const&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qpaintdevice.html#metric">QPaintDevice::metric</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/paintEngine" />
<h3 class="fn"><a name="paintEngine"></a><a href="qpaintengine.html">QPaintEngine</a> * QGLPixelBuffer::paintEngine () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qpaintdevice.html#paintEngine">QPaintDevice::paintEngine</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/releaseFromDynamicTexture" />
<h3 class="fn"><a name="releaseFromDynamicTexture"></a>void QGLPixelBuffer::releaseFromDynamicTexture ()</h3>
<p>Releases the pbuffer from any previously bound texture.</p>
<p>See also <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>().</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/size" />
<h3 class="fn"><a name="size"></a><a href="qsize.html">QSize</a> QGLPixelBuffer::size () const</h3>
<p>Returns the size of the pbuffer.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/toImage" />
<h3 class="fn"><a name="toImage"></a><a href="qimage.html">QImage</a> QGLPixelBuffer::toImage () const</h3>
<p>Returns the contents of the pbuffer as a <a href="qimage.html">QImage</a>.</p>
<a name="//apple_ref/cpp/instm/QGLPixelBuffer/updateDynamicTexture" />
<h3 class="fn"><a name="updateDynamicTexture"></a>void QGLPixelBuffer::updateDynamicTexture ( GLuint <i>texture_id</i> ) const</h3>
<p>Copies the pbuffer contents into the texture specified with <i>texture_id</i>.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>Example:</p>
<pre> QGLPixelBuffer pbuffer(...);
 ...
 pbuffer.makeCurrent();
 GLuint dynamicTexture = pbuffer.generateDynamicTexture();
 ...
 pbuffer.updateDynamicTexture(dynamicTexture);</pre>
<p>An alternative on Windows and Mac OS X systems that support the <tt>render_texture</tt> extension is to use <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>() to get dynamic updates of the texture.</p>
<p>See also <a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>() and <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="40%" align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="40%" align="right"><div align="right">Qt 4.6.0</div></td>
</tr></table></div></address></body>
</html>
