<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- qtestcase.cpp -->
<head>
  <title>Qt 4.6: QTest Namespace Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot; <a href="overviews.html"><font color="#004faf">Overviews</font></a></td></tr></table><h1 class="title">QTest Namespace Reference<br /><span class="small-subtitle">[<a href="qttest.html">QtTest</a> module]</span>
</h1>
<p>The QTest namespace contains all the functions and declarations that are related to the <a href="qtestlib-manual.html#qtestlib">QTestLib</a> tool. <a href="#details">More...</a></p>
<pre> #include &lt;QTest&gt;</pre><ul>
</ul>
<hr />
<a name="classes"></a>
<h2>Classes</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">class </td><td class="memItemRight" valign="bottom"><b><a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></b></td></tr>
</table>
<hr />
<a name="types"></a>
<h2>Types</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#AttributeIndex-enum">AttributeIndex</a></b> { AI_Undefined, AI_Name, AI_Result, AI_Tests, ..., AI_Iterations }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#KeyAction-enum">KeyAction</a></b> { Press, Release, Click }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#LogElementType-enum">LogElementType</a></b> { LET_Undefined, LET_Property, LET_Properties, LET_Failure, ..., LET_SystemError }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#MouseAction-enum">MouseAction</a></b> { MousePress, MouseRelease, MouseClick, MouseDClick, MouseMove }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#SkipMode-enum">SkipMode</a></b> { SkipSingle, SkipAll }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#TestFailMode-enum">TestFailMode</a></b> { Abort, Continue }</td></tr>
</table>
<hr />
<a name="functions"></a>
<h2>Functions</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#addColumn">addColumn</a></b> ( const char * <i>name</i>, T * <i>dummy</i> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#currentDataTag">currentDataTag</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#currentTestFailed">currentTestFailed</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#currentTestFunction">currentTestFunction</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#ignoreMessage">ignoreMessage</a></b> ( QtMsgType <i>type</i>, const char * <i>message</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyClick">keyClick</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyClick-2">keyClick</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyClicks">keyClicks</a></b> ( QWidget * <i>widget</i>, const QString &amp; <i>sequence</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyEvent">keyEvent</a></b> ( KeyAction <i>action</i>, QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyEvent-2">keyEvent</a></b> ( KeyAction <i>action</i>, QWidget * <i>widget</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyPress">keyPress</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyPress-2">keyPress</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyRelease">keyRelease</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#keyRelease-2">keyRelease</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#mouseClick">mouseClick</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#mouseDClick">mouseDClick</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#mouseMove">mouseMove</a></b> ( QWidget * <i>widget</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#mousePress">mousePress</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#mouseRelease">mouseRelease</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QTestData &amp; </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#newRow">newRow</a></b> ( const char * <i>dataTag</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#qExec">qExec</a></b> ( QObject * <i>testObject</i>, int <i>argc</i> = 0, char ** <i>argv</i> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#qExec-2">qExec</a></b> ( QObject * <i>testObject</i>, const QStringList &amp; <i>arguments</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#qSleep">qSleep</a></b> ( int <i>ms</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#qWait">qWait</a></b> ( int <i>ms</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#qWaitForWindowShown">qWaitForWindowShown</a></b> ( QWidget * <i>window</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toHexRepresentation">toHexRepresentation</a></b> ( const char * <i>ba</i>, int <i>length</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString">toString</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-4">toString</a></b> ( const QLatin1String &amp; <i>string</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-5">toString</a></b> ( const QString &amp; <i>string</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-6">toString</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-7">toString</a></b> ( const QTime &amp; <i>time</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-8">toString</a></b> ( const QDate &amp; <i>date</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-9">toString</a></b> ( const QDateTime &amp; <i>dateTime</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-10">toString</a></b> ( const QChar &amp; <i>character</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-11">toString</a></b> ( const QPoint &amp; <i>point</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-12">toString</a></b> ( const QSize &amp; <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-13">toString</a></b> ( const QRect &amp; <i>rectangle</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-14">toString</a></b> ( const QUrl &amp; <i>url</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-15">toString</a></b> ( const QPointF &amp; <i>point</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-16">toString</a></b> ( const QSizeF &amp; <i>size</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-17">toString</a></b> ( const QRectF &amp; <i>rectangle</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char * </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#toString-18">toString</a></b> ( const QVariant &amp; <i>variant</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QTouchEventSequence </td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#touchEvent">touchEvent</a></b> ( QWidget * <i>widget</i> = 0, QTouchEvent::DeviceType <i>deviceType</i> = QTouchEvent::TouchScreen )</td></tr>
</table>
<hr />
<a name="macros"></a>
<h2>Macros</h2>
<table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QBENCHMARK">QBENCHMARK</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QBENCHMARK_ONCE">QBENCHMARK_ONCE</a></b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QCOMPARE">QCOMPARE</a></b> (  <i>actual</i>,  <i>expected</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a></b> (  <i>dataIndex</i>,  <i>comment</i>,  <i>mode</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QFAIL">QFAIL</a></b> (  <i>message</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QFETCH">QFETCH</a></b> (  <i>type</i>,  <i>name</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QSKIP">QSKIP</a></b> (  <i>description</i>,  <i>mode</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QTEST">QTEST</a></b> (  <i>actual</i>,  <i>testElement</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a></b> (  <i>TestClass</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a></b> (  <i>TestClass</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QTEST_NOOP_MAIN">QTEST_NOOP_MAIN</a></b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QVERIFY2">QVERIFY2</a></b> (  <i>condition</i>,  <i>message</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QVERIFY">QVERIFY</a></b> (  <i>condition</i> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><b><a href="qtest.html#QWARN">QWARN</a></b> (  <i>message</i> )</td></tr>
</table>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QTest namespace contains all the functions and declarations that are related to the <a href="qtestlib-manual.html#qtestlib">QTestLib</a> tool.</p>
<p>Please refer to the <a href="qtestlib-manual.html">QTestLib Manual</a> documentation for information on how to write unit tests.</p>
<hr />
<h2>Classes</h2>
<h3> class <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></h3><p>The QTouchEventSequence class is used to simulate a sequence of touch events. <a href="qtest-qtoucheventsequence.html#details">More...</a></p>
<hr />
<h2>Type Documentation</h2>
<a name="//apple_ref/cpp/tag/QTest/AttributeIndex" />
<a name="//apple_ref/cpp/econst/QTest/AI_Undefined" />
<a name="//apple_ref/cpp/econst/QTest/AI_Name" />
<a name="//apple_ref/cpp/econst/QTest/AI_Result" />
<a name="//apple_ref/cpp/econst/QTest/AI_Tests" />
<a name="//apple_ref/cpp/econst/QTest/AI_Failures" />
<a name="//apple_ref/cpp/econst/QTest/AI_Errors" />
<a name="//apple_ref/cpp/econst/QTest/AI_Type" />
<a name="//apple_ref/cpp/econst/QTest/AI_Description" />
<a name="//apple_ref/cpp/econst/QTest/AI_PropertyValue" />
<a name="//apple_ref/cpp/econst/QTest/AI_QTestVersion" />
<a name="//apple_ref/cpp/econst/QTest/AI_QtVersion" />
<a name="//apple_ref/cpp/econst/QTest/AI_File" />
<a name="//apple_ref/cpp/econst/QTest/AI_Line" />
<a name="//apple_ref/cpp/econst/QTest/AI_Metric" />
<a name="//apple_ref/cpp/econst/QTest/AI_Tag" />
<a name="//apple_ref/cpp/econst/QTest/AI_Value" />
<a name="//apple_ref/cpp/econst/QTest/AI_Iterations" />
<h3 class="fn"><a name="AttributeIndex-enum"></a>enum QTest::AttributeIndex</h3>
<p>This enum numbers the different tests.</p>
<p><table  class="valuelist" border="1" cellpadding="2" cellspacing="1" width="40%">
<tr><th width="60%">Constant</th><th width="40%">Value</th></tr>
<tr><td valign="top"><tt>QTest::AI_Undefined</tt></td><td align="center" valign="top"><tt>-1</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Name</tt></td><td align="center" valign="top"><tt>0</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Result</tt></td><td align="center" valign="top"><tt>1</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Tests</tt></td><td align="center" valign="top"><tt>2</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Failures</tt></td><td align="center" valign="top"><tt>3</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Errors</tt></td><td align="center" valign="top"><tt>4</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Type</tt></td><td align="center" valign="top"><tt>5</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Description</tt></td><td align="center" valign="top"><tt>6</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_PropertyValue</tt></td><td align="center" valign="top"><tt>7</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_QTestVersion</tt></td><td align="center" valign="top"><tt>8</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_QtVersion</tt></td><td align="center" valign="top"><tt>9</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_File</tt></td><td align="center" valign="top"><tt>10</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Line</tt></td><td align="center" valign="top"><tt>11</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Metric</tt></td><td align="center" valign="top"><tt>12</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Tag</tt></td><td align="center" valign="top"><tt>13</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Value</tt></td><td align="center" valign="top"><tt>14</tt></td></tr>
<tr><td valign="top"><tt>QTest::AI_Iterations</tt></td><td align="center" valign="top"><tt>15</tt></td></tr>
</table></p>
<a name="//apple_ref/cpp/tag/QTest/KeyAction" />
<a name="//apple_ref/cpp/econst/QTest/Press" />
<a name="//apple_ref/cpp/econst/QTest/Release" />
<a name="//apple_ref/cpp/econst/QTest/Click" />
<h3 class="fn"><a name="KeyAction-enum"></a>enum QTest::KeyAction</h3>
<p>This enum describes possible actions for key handling.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QTest::Press</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">The key is pressed.</td></tr>
<tr><td valign="top"><tt>QTest::Release</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The key is released.</td></tr>
<tr><td valign="top"><tt>QTest::Click</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">The key is clicked (pressed and released).</td></tr>
</table></p>
<a name="//apple_ref/cpp/tag/QTest/LogElementType" />
<a name="//apple_ref/cpp/econst/QTest/LET_Undefined" />
<a name="//apple_ref/cpp/econst/QTest/LET_Property" />
<a name="//apple_ref/cpp/econst/QTest/LET_Properties" />
<a name="//apple_ref/cpp/econst/QTest/LET_Failure" />
<a name="//apple_ref/cpp/econst/QTest/LET_Error" />
<a name="//apple_ref/cpp/econst/QTest/LET_TestCase" />
<a name="//apple_ref/cpp/econst/QTest/LET_TestSuite" />
<a name="//apple_ref/cpp/econst/QTest/LET_Benchmark" />
<a name="//apple_ref/cpp/econst/QTest/LET_SystemError" />
<h3 class="fn"><a name="LogElementType-enum"></a>enum QTest::LogElementType</h3>
<p>The enum specifies the kinds of test log messages.</p>
<p><table  class="valuelist" border="1" cellpadding="2" cellspacing="1" width="40%">
<tr><th width="60%">Constant</th><th width="40%">Value</th></tr>
<tr><td valign="top"><tt>QTest::LET_Undefined</tt></td><td align="center" valign="top"><tt>-1</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_Property</tt></td><td align="center" valign="top"><tt>0</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_Properties</tt></td><td align="center" valign="top"><tt>1</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_Failure</tt></td><td align="center" valign="top"><tt>2</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_Error</tt></td><td align="center" valign="top"><tt>3</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_TestCase</tt></td><td align="center" valign="top"><tt>4</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_TestSuite</tt></td><td align="center" valign="top"><tt>5</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_Benchmark</tt></td><td align="center" valign="top"><tt>6</tt></td></tr>
<tr><td valign="top"><tt>QTest::LET_SystemError</tt></td><td align="center" valign="top"><tt>7</tt></td></tr>
</table></p>
<a name="//apple_ref/cpp/tag/QTest/MouseAction" />
<a name="//apple_ref/cpp/econst/QTest/MousePress" />
<a name="//apple_ref/cpp/econst/QTest/MouseRelease" />
<a name="//apple_ref/cpp/econst/QTest/MouseClick" />
<a name="//apple_ref/cpp/econst/QTest/MouseDClick" />
<a name="//apple_ref/cpp/econst/QTest/MouseMove" />
<h3 class="fn"><a name="MouseAction-enum"></a>enum QTest::MouseAction</h3>
<p>This enum describes possible actions for mouse handling.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QTest::MousePress</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">A mouse button is pressed.</td></tr>
<tr><td valign="top"><tt>QTest::MouseRelease</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">A mouse button is released.</td></tr>
<tr><td valign="top"><tt>QTest::MouseClick</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">A mouse button is clicked (pressed and released).</td></tr>
<tr><td valign="top"><tt>QTest::MouseDClick</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">A mouse button is double clicked (pressed and released twice).</td></tr>
<tr><td valign="top"><tt>QTest::MouseMove</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The mouse pointer has moved.</td></tr>
</table></p>
<a name="//apple_ref/cpp/tag/QTest/SkipMode" />
<a name="//apple_ref/cpp/econst/QTest/SkipSingle" />
<a name="//apple_ref/cpp/econst/QTest/SkipAll" />
<h3 class="fn"><a name="SkipMode-enum"></a>enum QTest::SkipMode</h3>
<p>This enum describes the modes for skipping tests during execution of the test data.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QTest::SkipSingle</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">Skips the current entry in the test table; continues execution of all the other entries in the table.</td></tr>
<tr><td valign="top"><tt>QTest::SkipAll</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">Skips all the entries in the test table; the test won't be executed further.</td></tr>
</table></p>
<p>See also <a href="qtest.html#QSKIP">QSKIP</a>().</p>
<a name="//apple_ref/cpp/tag/QTest/TestFailMode" />
<a name="//apple_ref/cpp/econst/QTest/Abort" />
<a name="//apple_ref/cpp/econst/QTest/Continue" />
<h3 class="fn"><a name="TestFailMode-enum"></a>enum QTest::TestFailMode</h3>
<p>This enum describes the modes for handling an expected failure of the <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() macros.</p>
<p><table class="valuelist" border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QTest::Abort</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">Aborts the execution of the test. Use this mode when it doesn't make sense to execute the test any further after the expected failure.</td></tr>
<tr><td valign="top"><tt>QTest::Continue</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">Continues execution of the test after the expected failure.</td></tr>
</table></p>
<p>See also <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>
<hr />
<h2>Function Documentation</h2>
<a name="//apple_ref/cpp/instm/QTest/addColumn" />
<h3 class="fn"><a name="addColumn"></a>void QTest::addColumn ( const char * <i>name</i>, T * <i>dummy</i> = 0 )</h3>
<p>Adds a column with type <tt>T</tt> to the current test data. <i>name</i> is the name of the column. <i>dummy</i> is a workaround for buggy compilers and can be ignored.</p>
<p>To populate the column with values, <a href="qtest.html#newRow">newRow</a>() can be used. Use <a href="qtest.html#QFETCH">QFETCH</a>() to fetch the data in the actual test.</p>
<p>Example:</p>
<pre> void myTestFunction_data() {
     QTest::addColumn&lt;int&gt;(&quot;intval&quot;);
     QTest::addColumn&lt;QString&gt;(&quot;str&quot;);
     QTest::addColumn&lt;double&gt;(&quot;dbl&quot;);

     QTest::newRow(&quot;row1&quot;) &lt;&lt; 1 &lt;&lt; &quot;hello&quot; &lt;&lt; 1.5;
 }</pre>
<p>To add custom types to the testdata, the type must be registered with <a href="qmetatype.html">QMetaType</a> via <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p>
<p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p>
<p>See <a href="qtestlib-tutorial2.html">Data Driven Testing</a> for a more extensive example.</p>
<p>See also <a href="qtest.html#newRow">QTest::newRow</a>(), <a href="qtest.html#QFETCH">QFETCH</a>(), and <a href="qmetatype.html">QMetaType</a>.</p>
<a name="//apple_ref/cpp/instm/QTest/currentDataTag" />
<h3 class="fn"><a name="currentDataTag"></a>const char * QTest::currentDataTag ()</h3>
<p>Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns 0.</p>
<a name="//apple_ref/cpp/instm/QTest/currentTestFailed" />
<h3 class="fn"><a name="currentTestFailed"></a>bool QTest::currentTestFailed ()</h3>
<p>Returns true if the current test function failed, otherwise false.</p>
<a name="//apple_ref/cpp/instm/QTest/currentTestFunction" />
<h3 class="fn"><a name="currentTestFunction"></a>const char * QTest::currentTestFunction ()</h3>
<p>Returns the name of the test function that is currently executed.</p>
<p>Example:</p>
<pre> void MyTestClass::cleanup()
 {
     if (qstrcmp(currentTestFunction(), &quot;myDatabaseTest&quot;) == 0) {
         <span class="comment">// clean up all database connections</span>
         closeAllDatabases();
     }
 }</pre>
<a name="//apple_ref/cpp/instm/QTest/ignoreMessage" />
<h3 class="fn"><a name="ignoreMessage"></a>void QTest::ignoreMessage ( <a href="qtglobal.html#QtMsgType-enum">QtMsgType</a> <i>type</i>, const char * <i>message</i> )</h3>
<p>Ignores messages created by <a href="qtglobal.html#qDebug">qDebug</a>() or <a href="qtglobal.html#qWarning">qWarning</a>(). If the <i>message</i> with the corresponding <i>type</i> is outputted, it will be removed from the test log. If the test finished and the <i>message</i> was not outputted, a test failure is appended to the test log.</p>
<p><b>Note:</b> Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.</p>
<p>Example:</p>
<pre> QDir dir;

 QTest::ignoreMessage(QtWarningMsg, &quot;QDir::mkdir: Empty or null file name(s)&quot;);
 dir.mkdir(&quot;&quot;);</pre>
<p>The example above tests that <a href="qdir.html#mkdir">QDir::mkdir</a>() outputs the right warning when invoked with an invalid file name.</p>
<a name="//apple_ref/cpp/clm/QTest/keyClick" />
<h3 class="fn"><a name="keyClick"></a>void QTest::keyClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>Examples:</p>
<pre> QTest::keyClick(myWidget, Qt::Key_Escape);

 QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);</pre>
<p>The first example above simulates clicking the <tt>escape</tt> key on <tt>myWidget</tt> without any keyboard modifiers and without delay. The second example simulates clicking <tt>shift-escape</tt> on <tt>myWidget</tt> with a following 200 ms delay of the test.</p>
<p>See also <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>
<h3 class="fn"><a name="keyClick-2"></a>void QTest::keyClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>Example:</p>
<pre> QTest::keyClick(myWidget, 'a');</pre>
<p>The example above simulates clicking <tt>a</tt> on <tt>myWidget</tt> without any keyboard modifiers and without delay of the test.</p>
<p>See also <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>
<a name="//apple_ref/cpp/clm/QTest/keyClicks" />
<h3 class="fn"><a name="keyClicks"></a>void QTest::keyClicks ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, const <a href="qstring.html">QString</a> &amp; <i>sequence</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Simulates clicking a <i>sequence</i> of keys on a <i>widget</i>. Optionally, a keyboard <i>modifier</i> can be specified as well as a <i>delay</i> (in milliseconds) of the test before each key click.</p>
<p>Example:</p>
<pre> QTest::keyClicks(myWidget, &quot;hello world&quot;);</pre>
<p>The example above simulates clicking the sequence of keys representing &quot;hello world&quot; on <tt>myWidget</tt> without any keyboard modifiers and without delay of the test.</p>
<p>See also <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<a name="//apple_ref/cpp/clm/QTest/keyEvent" />
<h3 class="fn"><a name="keyEvent"></a>void QTest::keyEvent ( <a href="qtest.html#KeyAction-enum">KeyAction</a> <i>action</i>, <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Sends a Qt key event to <i>widget</i> with the given <i>key</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>
<h3 class="fn"><a name="keyEvent-2"></a>void QTest::keyEvent ( <a href="qtest.html#KeyAction-enum">KeyAction</a> <i>action</i>, <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>ascii</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Sends a Qt key event to <i>widget</i> with the given key <i>ascii</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>
<a name="//apple_ref/cpp/clm/QTest/keyPress" />
<h3 class="fn"><a name="keyPress"></a>void QTest::keyPress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p><b>Note:</b> At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p>
<p>See also <a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<h3 class="fn"><a name="keyPress-2"></a>void QTest::keyPress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p><b>Note:</b> At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p>
<p>See also <a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<a name="//apple_ref/cpp/clm/QTest/keyRelease" />
<h3 class="fn"><a name="keyRelease"></a>void QTest::keyRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>See also <a href="qtest.html#keyPress">QTest::keyPress</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<h3 class="fn"><a name="keyRelease-2"></a>void QTest::keyRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>See also <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/mouseClick" />
<h3 class="fn"><a name="mouseClick"></a>void QTest::mouseClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p>
<p>See also <a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/mouseDClick" />
<h3 class="fn"><a name="mouseDClick"></a>void QTest::mouseDClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates double clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p>
<p>See also <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/mouseMove" />
<h3 class="fn"><a name="mouseMove"></a>void QTest::mouseMove ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Moves the mouse pointer to a <i>widget</i>. If <i>pos</i> is not specified, the mouse pointer moves to the center of the widget. If a <i>delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p>
<a name="//apple_ref/cpp/instm/QTest/mousePress" />
<h3 class="fn"><a name="mousePress"></a>void QTest::mousePress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates pressing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p>
<p>See also <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/mouseRelease" />
<h3 class="fn"><a name="mouseRelease"></a>void QTest::mouseRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates releasing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the release is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button.</p>
<p>See also <a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/newRow" />
<h3 class="fn"><a name="newRow"></a>QTestData &amp; QTest::newRow ( const char * <i>dataTag</i> )</h3>
<p>Appends a new row to the current test data. <i>dataTag</i> is the name of the testdata that will appear in the test output. Returns a QTestData reference that can be used to stream in data.</p>
<p>Example:</p>
<pre> void myTestFunction_data()
 {
     QTest::addColumn&lt;QString&gt;(&quot;aString&quot;);
     QTest::newRow(&quot;just hello&quot;) &lt;&lt; QString(&quot;hello&quot;);
     QTest::newRow(&quot;a null string&quot;) &lt;&lt; QString();
 }</pre>
<p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p>
<p>See <a href="qtestlib-tutorial2.html">Data Driven Testing</a> for a more extensive example.</p>
<p>See also <a href="qtest.html#addColumn">addColumn</a>() and <a href="qtest.html#QFETCH">QFETCH</a>().</p>
<a name="//apple_ref/cpp/instm/QTest/qExec" />
<h3 class="fn"><a name="qExec"></a>int QTest::qExec ( <a href="qobject.html">QObject</a> * <i>testObject</i>, int <i>argc</i> = 0, char ** <i>argv</i> = 0 )</h3>
<p>Executes tests declared in <i>testObject</i>. In addition, the private slots <tt>initTestCase()</tt>, <tt>cleanupTestCase()</tt>, <tt>init()</tt> and <tt>cleanup()</tt> are executed if they exist. See <a href="qtestlib-manual.html#creating-a-test">Creating a Test</a> for more details.</p>
<p>Optionally, the command line arguments <i>argc</i> and <i>argv</i> can be provided. For a list of recognized arguments, read <a href="qtestlib-manual.html#qtestlib-command-line-arguments">QTestLib Command Line Arguments</a>.</p>
<p>For stand-alone tests, the convenience macro <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() can be used to declare a main method that parses the command line arguments and executes the tests.</p>
<p>Returns 0 if all tests passed. Returns a value other than 0 if tests failed or in case of unhandled exceptions. The return value from this function is also the exit code of the test application when the <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() macro is used.</p>
<p>The following example will run all tests in <tt>MyFirstTestObject</tt> and <tt>MySecondTestObject</tt>:</p>
<pre> MyFirstTestObject test1;
 QTest::qExec(&amp;test1);

 MySecondTestObject test2;
 QTest::qExec(&amp;test2);</pre>
<p>Note: This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</p>
<p>If you have programatically created the arguments, as opposed to getting them from the arguments in <tt>main()</tt>, it is likely of interest to use QTest::qExec(<a href="qobject.html">QObject</a> *, const <a href="qstringlist.html">QStringList</a> &amp;) since it is Unicode safe.</p>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<h3 class="fn"><a name="qExec-2"></a>int QTest::qExec ( <a href="qobject.html">QObject</a> * <i>testObject</i>, const <a href="qstringlist.html">QStringList</a> &amp; <i>arguments</i> )</h3>
<p>This is an overloaded function.</p>
<p>Behaves identically to qExec(<a href="qobject.html">QObject</a> *, int, char**) but takes a <a href="qstringlist.html">QStringList</a> of <i>arguments</i> instead of a <tt>char**</tt> list.</p>
<p>This function was introduced in Qt 4.4.</p>
<a name="//apple_ref/cpp/instm/QTest/qSleep" />
<h3 class="fn"><a name="qSleep"></a>void QTest::qSleep ( int <i>ms</i> )</h3>
<p>Sleeps for <i>ms</i> milliseconds, blocking execution of the test. qSleep() will not do any event processing and leave your test unresponsive. Network communication might time out while sleeping. Use <a href="qtest.html#qWait">qWait</a>() to do non-blocking sleeping.</p>
<p><i>ms</i> must be greater than 0.</p>
<p><b>Note:</b> The qSleep() function calls either <tt>nanosleep()</tt> on unix or <tt>Sleep()</tt> on windows, so the accuracy of time spent in qSleep() depends on the operating system.</p>
<p>Example:</p>
<pre> QTest::qSleep(250);</pre>
<p>See also <a href="qtest.html#qWait">qWait</a>().</p>
<a name="//apple_ref/cpp/clm/QTest/qWait" />
<h3 class="fn"><a name="qWait"></a>void QTest::qWait ( int <i>ms</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Waits for <i>ms</i> milliseconds. While waiting, events will be processed and your test will stay responsive to user interface events or network communication.</p>
<p>Example:</p>
<pre> int i = 0;
 while (myNetworkServerNotResponding() &amp;&amp; i++ &lt; 50)
     QTest::qWait(250);</pre>
<p>The code above will wait until the network server is responding for a maximum of about 12.5 seconds.</p>
<p>See also <a href="qtest.html#qSleep">QTest::qSleep</a>().</p>
<a name="//apple_ref/cpp/clm/QTest/qWaitForWindowShown" />
<h3 class="fn"><a name="qWaitForWindowShown"></a>bool QTest::qWaitForWindowShown ( <a href="qwidget.html">QWidget</a> * <i>window</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Waits until the <i>window</i> is shown in the screen. This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some time after being asked to show itself on the screen. Returns true.</p>
<p>Example:</p>
<pre> QWidget widget;
 widget.show();
 QTest::qWaitForWindowShown(&amp;widget);</pre>
<p>This function was introduced in Qt 4.6.</p>
<a name="//apple_ref/cpp/instm/QTest/toHexRepresentation" />
<h3 class="fn"><a name="toHexRepresentation"></a>char * QTest::toHexRepresentation ( const char * <i>ba</i>, int <i>length</i> )</h3>
<p>Returns a pointer to a string that is the string <i>ba</i> represented as a space-separated sequence of hex characters. If the input is considered too long, it is truncated. A trucation is indicated in the returned string as an ellipsis at the end.</p>
<p><i>length</i> is the length of the string <i>ba</i>.</p>
<a name="//apple_ref/cpp/instm/QTest/toString" />
<h3 class="fn"><a name="toString"></a>char * QTest::toString ( const T &amp; <i>value</i> )</h3>
<p>Returns a textual representation of <i>value</i>. This function is used by <a href="qtest.html#QCOMPARE">QCOMPARE</a>() to output verbose information in case of a test failure.</p>
<p>You can add specializations of this function to your test to enable verbose output.</p>
<p><b>Note:</b> The caller of toString() must delete the returned data using <tt>delete[]</tt>. Your implementation should return a string created with <tt>new[]</tt> or <a href="qbytearray.html#qstrdup">qstrdup</a>().</p>
<p>Example:</p>
<pre> namespace QTest {
     template&lt;&gt;
     char *toString(const MyPoint &amp;point)
     {
         QByteArray ba = &quot;MyPoint(&quot;;
         ba += QByteArray::number(point.x()) + &quot;, &quot; + QByteArray::number(point.y());
         ba += &quot;)&quot;;
         return qstrdup(ba.data());
     }
 }</pre>
<p>The example above defines a toString() specialization for a class called <tt>MyPoint</tt>. Whenever a comparison of two instances of <tt>MyPoint</tt> fails, <a href="qtest.html#QCOMPARE">QCOMPARE</a>() will call this function to output the contents of <tt>MyPoint</tt> to the test log.</p>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<h3 class="fn"><a name="toString-4"></a>char * QTest::toString ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>string</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>string</i>.</p>
<h3 class="fn"><a name="toString-5"></a>char * QTest::toString ( const <a href="qstring.html">QString</a> &amp; <i>string</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>string</i>.</p>
<h3 class="fn"><a name="toString-6"></a>char * QTest::toString ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the byte array <i>ba</i>.</p>
<p>See also <a href="qtest.html#toHexRepresentation">QTest::toHexRepresentation</a>().</p>
<h3 class="fn"><a name="toString-7"></a>char * QTest::toString ( const <a href="qtime.html">QTime</a> &amp; <i>time</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>time</i>.</p>
<h3 class="fn"><a name="toString-8"></a>char * QTest::toString ( const <a href="qdate.html">QDate</a> &amp; <i>date</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>date</i>.</p>
<h3 class="fn"><a name="toString-9"></a>char * QTest::toString ( const <a href="qdatetime.html">QDateTime</a> &amp; <i>dateTime</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the date and time specified by <i>dateTime</i>.</p>
<h3 class="fn"><a name="toString-10"></a>char * QTest::toString ( const <a href="qchar.html">QChar</a> &amp; <i>character</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>character</i>.</p>
<h3 class="fn"><a name="toString-11"></a>char * QTest::toString ( const <a href="qpoint.html">QPoint</a> &amp; <i>point</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>point</i>.</p>
<h3 class="fn"><a name="toString-12"></a>char * QTest::toString ( const <a href="qsize.html">QSize</a> &amp; <i>size</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>size</i>.</p>
<h3 class="fn"><a name="toString-13"></a>char * QTest::toString ( const <a href="qrect.html">QRect</a> &amp; <i>rectangle</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>rectangle</i>.</p>
<h3 class="fn"><a name="toString-14"></a>char * QTest::toString ( const <a href="qurl.html">QUrl</a> &amp; <i>url</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>url</i>.</p>
<p>This function was introduced in Qt 4.4.</p>
<h3 class="fn"><a name="toString-15"></a>char * QTest::toString ( const <a href="qpointf.html">QPointF</a> &amp; <i>point</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>point</i>.</p>
<h3 class="fn"><a name="toString-16"></a>char * QTest::toString ( const <a href="qsizef.html">QSizeF</a> &amp; <i>size</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>size</i>.</p>
<h3 class="fn"><a name="toString-17"></a>char * QTest::toString ( const <a href="qrectf.html">QRectF</a> &amp; <i>rectangle</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>rectangle</i>.</p>
<h3 class="fn"><a name="toString-18"></a>char * QTest::toString ( const <a href="qvariant.html">QVariant</a> &amp; <i>variant</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>variant</i>.</p>
<a name="//apple_ref/cpp/instm/QTest/touchEvent" />
<h3 class="fn"><a name="touchEvent"></a><a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> QTest::touchEvent ( <a href="qwidget.html">QWidget</a> * <i>widget</i> = 0, <a href="qtouchevent.html#DeviceType-enum">QTouchEvent::DeviceType</a> <i>deviceType</i> = QTouchEvent::TouchScreen )</h3>
<p>Creates and returns a <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> for the device <i>deviceType</i> to simulate events for <i>widget</i>.</p>
<p>When adding touch events to the sequence, <i>widget</i> will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.</p>
<p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> is called (ie when the object returned runs out of scope).</p>
<hr />
<h2>Macro Documentation</h2>
<a name="//apple_ref/cpp/macro//QBENCHMARK" />
<h3 class="fn"><a name="QBENCHMARK"></a>QBENCHMARK</h3>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>For example:</p>
<pre> void TestBenchmark::simple()
 {
     QString str1 = QLatin1String(&quot;This is a test string&quot;);
     QString str2 = QLatin1String(&quot;This is a test string&quot;);

     QCOMPARE(str1.localeAwareCompare(str2), 0);

     QBENCHMARK {
         str1.localeAwareCompare(str2);
     }
 }</pre>
<p>See also <a href="qtestlib-manual.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="qtestlib-tutorial5.html">Writing a Benchmark</a>.</p>
<a name="//apple_ref/cpp/macro//QBENCHMARK_ONCE" />
<h3 class="fn"><a name="QBENCHMARK_ONCE"></a>QBENCHMARK_ONCE</h3>
<p>The QBENCHMARK_ONCE macro is for measuring performance of a code block by running it once.</p>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>Unlike QBENCHMARK, the contents of the contained code block is only run once. The elapsed time will be reported as &quot;0&quot; if it's to short to be measured by the selected backend. (Use)</p>
<p>This function was introduced in Qt 4.6.</p>
<p>See also <a href="qtestlib-manual.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="qtestlib-tutorial5.html">Writing a Benchmark</a>.</p>
<a name="//apple_ref/cpp/macro//QCOMPARE" />
<h3 class="fn"><a name="QCOMPARE"></a>QCOMPARE (  <i>actual</i>,  <i>expected</i> )</h3>
<p>The QCOMPARE macro compares an <i>actual</i> value to an <i>expected</i> value using the equals operator. If <i>actual</i> and <i>expected</i> are identical, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p>
<p>In the case of comparing floats and doubles, <a href="qvector4d.html#qFuzzyCompare">qFuzzyCompare</a>() is used for comparing. This means that comparing to 0 will likely fail. One solution to this is to compare to 1, and add 1 to the produced output.</p>
<p>QCOMPARE tries to output the contents of the values if the comparison fails, so it is visible from the test log why the comparison failed.</p>
<p>QCOMPARE is very strict on the data types. Both <i>actual</i> and <i>expected</i> have to be of the same type, otherwise the test won't compile. This prohibits unspecified behavior from being introduced; that is behavior that usually occurs when the compiler implicitly casts the argument.</p>
<p>If you use QCOMPARE() to compare two <a href="qstringlist.html">QStringList</a> objects, it will start comparing the objects from the end of the lists.</p>
<p>For your own classes, you can use <a href="qtest.html#toString">QTest::toString</a>() to format values for outputting into the test log.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre> QCOMPARE(QString(&quot;hello&quot;).toUpper(), QString(&quot;HELLO&quot;));</pre>
<p>See also <a href="qtest.html#QVERIFY">QVERIFY</a>() and <a href="qtest.html#toString">QTest::toString</a>().</p>
<a name="//apple_ref/cpp/macro//QEXPECT_FAIL" />
<h3 class="fn"><a name="QEXPECT_FAIL"></a>QEXPECT_FAIL (  <i>dataIndex</i>,  <i>comment</i>,  <i>mode</i> )</h3>
<p>The QEXPECT_FAIL() macro marks the next <a href="qtest.html#QCOMPARE">QCOMPARE</a>() or <a href="qtest.html#QVERIFY">QVERIFY</a>() as an expected failure. Instead of adding a failure to the test log, an expected failure will be reported.</p>
<p>If a <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log.</p>
<p>The parameter <i>dataIndex</i> describes for which entry in the test data the failure is expected. Pass an empty string (<tt>&quot;&quot;</tt>) if the failure is expected for all entries or if no test data exists.</p>
<p><i>comment</i> will be appended to the test log for the expected failure.</p>
<p><i>mode</i> is a <a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a> and sets whether the test should continue to execute or not.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example 1:</p>
<pre> QEXPECT_FAIL(&quot;&quot;, &quot;Will fix in the next release&quot;, Continue);
 QCOMPARE(i, 42);
 QCOMPARE(j, 43);</pre>
<p>In the example above, an expected fail will be written into the test output if the variable <tt>i</tt> is not 42. If the variable <tt>i</tt> is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second <a href="qtest.html#QCOMPARE">QCOMPARE</a>() statement in the example.</p>
<p>Example 2:</p>
<pre> QEXPECT_FAIL(&quot;data27&quot;, &quot;Oh my, this is soooo broken&quot;, Abort);
 QCOMPARE(i, 42);</pre>
<p>The above testfunction will not continue executing for the test data entry <tt>data27</tt>.</p>
<p>See also <a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a>, <a href="qtest.html#QVERIFY">QVERIFY</a>(), and <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<a name="//apple_ref/cpp/macro//QFAIL" />
<h3 class="fn"><a name="QFAIL"></a>QFAIL (  <i>message</i> )</h3>
<p>This macro can be used to force a test failure. The test stops executing and the failure <i>message</i> is appended to the test log.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre> if (sizeof(int) != 4)
     QFAIL(&quot;This test has not been ported to this platform yet.&quot;);</pre>
<a name="//apple_ref/cpp/macro//QFETCH" />
<h3 class="fn"><a name="QFETCH"></a>QFETCH (  <i>type</i>,  <i>name</i> )</h3>
<p>The fetch macro creates a local variable named <i>name</i> with the type <i>type</i> on the stack. <i>name</i> has to match the element name from the test's data. If no such element exists, the test will assert.</p>
<p>Assuming a test has the following data:</p>
<pre> void TestQString::toInt_data()
 {
     QTest::addColumn&lt;QString&gt;(&quot;aString&quot;);
     QTest::addColumn&lt;int&gt;(&quot;expected&quot;);

     QTest::newRow(&quot;positive value&quot;) &lt;&lt; &quot;42&quot; &lt;&lt; 42;
     QTest::newRow(&quot;negative value&quot;) &lt;&lt; &quot;-42&quot; &lt;&lt; -42;
     QTest::newRow(&quot;zero&quot;) &lt;&lt; &quot;0&quot; &lt;&lt; 0;
 }</pre>
<p>The test data has two elements, a <a href="qstring.html">QString</a> called <tt>aString</tt> and an integer called <tt>expected</tt>. To fetch these values in the actual test:</p>
<pre> void TestQString::toInt()
 {
      QFETCH(QString, aString);
      QFETCH(int, expected);

      QCOMPARE(aString.toInt(), expected);
 }</pre>
<p><tt>aString</tt> and <tt>expected</tt> are variables on the stack that are initialized with the current test data.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework. The test function must have a _data function.</p>
<a name="//apple_ref/cpp/macro//QSKIP" />
<h3 class="fn"><a name="QSKIP"></a>QSKIP (  <i>description</i>,  <i>mode</i> )</h3>
<p>The QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. The text <i>description</i> is appended to the test log and should contain an explanation why the test couldn't be executed. <i>mode</i> is a <a href="qtest.html#SkipMode-enum">QTest::SkipMode</a> and describes whether to proceed with the rest of the test data or not.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre> if (!QSqlDatabase::drivers().contains(&quot;SQLITE&quot;))
     QSKIP(&quot;This test requires the SQLITE database driver&quot;, SkipAll);</pre>
<p>See also <a href="qtest.html#SkipMode-enum">QTest::SkipMode</a>.</p>
<a name="//apple_ref/cpp/macro//QTEST" />
<h3 class="fn"><a name="QTEST"></a>QTEST (  <i>actual</i>,  <i>testElement</i> )</h3>
<p>QTEST() is a convenience macro for <a href="qtest.html#QCOMPARE">QCOMPARE</a>() that compares the value <i>actual</i> with the element <i>testElement</i> from the test's data. If there is no such element, the test asserts.</p>
<p>Apart from that, QTEST() behaves exactly as <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<p>Instead of writing:</p>
<pre> QFETCH(QString, myString);
 QCOMPARE(QString(&quot;hello&quot;).toUpper(), myString);</pre>
<p>you can write:</p>
<pre> QTEST(QString(&quot;hello&quot;).toUpper(), &quot;myString&quot;);</pre>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<a name="//apple_ref/cpp/macro//QTEST_APPLESS_MAIN" />
<h3 class="fn"><a name="QTEST_APPLESS_MAIN"></a>QTEST_APPLESS_MAIN (  <i>TestClass</i> )</h3>
<p>Implements a main() function that executes all tests in <i>TestClass</i>.</p>
<p>Behaves like <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>(), but doesn't instantiate a <a href="qapplication.html">QApplication</a> object. Use this macro for really simple stand-alone non-GUI tests.</p>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<a name="//apple_ref/cpp/macro//QTEST_MAIN" />
<h3 class="fn"><a name="QTEST_MAIN"></a>QTEST_MAIN (  <i>TestClass</i> )</h3>
<p>Implements a main() function that instantiates a <a href="qapplication.html">QApplication</a> object and the <i>TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p>
<p><b>Note:</b> On platforms that have keypad navigation enabled by default (eg: Symbian), this macro will forcfully disable it to simplify the usage of key events when writing autotests. If you wish to write a test case that uses keypad navigation, you should enable it either in the <tt>initTestCase()</tt> or <tt>init()</tt> functions of your test case.</p>
<p>Example:</p>
<pre> class TestQString: public QObject { ... };
 QTEST_MAIN(TestQString)</pre>
<p>See also <a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a>(), <a href="qtest.html#qExec">QTest::qExec</a>(), and <a href="qapplication.html#setNavigationMode">QApplication::setNavigationMode</a>().</p>
<a name="//apple_ref/cpp/macro//QTEST_NOOP_MAIN" />
<h3 class="fn"><a name="QTEST_NOOP_MAIN"></a>QTEST_NOOP_MAIN ()</h3>
<p>Implements a main() function with a test class that does absolutely nothing. Use this macro to create a test that produces valid test output but just doesn't execute any test, for example in conditional compilations:</p>
<pre> #ifdef Q_WS_X11
     QTEST_MAIN(MyX11Test)
 #else
     <span class="comment">// do nothing on non-X11 platforms</span>
     QTEST_NOOP_MAIN
 #endif</pre>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<a name="//apple_ref/cpp/macro//QVERIFY2" />
<h3 class="fn"><a name="QVERIFY2"></a>QVERIFY2 (  <i>condition</i>,  <i>message</i> )</h3>
<p>The QVERIFY2() macro behaves exactly like <a href="qtest.html#QVERIFY">QVERIFY</a>(), except that it outputs a verbose <i>message</i> when <i>condition</i> is false. The <i>message</i> is a plain C string.</p>
<p>Example:</p>
<pre> QVERIFY2(1 + 1 == 2, &quot;A breach in basic arithmetic occured.&quot;);</pre>
<p>See also <a href="qtest.html#QVERIFY">QVERIFY</a>() and <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<a name="//apple_ref/cpp/macro//QVERIFY" />
<h3 class="fn"><a name="QVERIFY"></a>QVERIFY (  <i>condition</i> )</h3>
<p>The QVERIFY() macro checks whether the <i>condition</i> is true or not. If it is true, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre> QVERIFY(1 + 1 == 2);</pre>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<a name="//apple_ref/cpp/macro//QWARN" />
<h3 class="fn"><a name="QWARN"></a>QWARN (  <i>message</i> )</h3>
<p>Appends <i>message</i> as a warning to the test log. This macro can be used anywhere in your tests.</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="40%" align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="40%" align="right"><div align="right">Qt 4.6.0</div></td>
</tr></table></div></address></body>
</html>
